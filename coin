import os
import time
import requests
import json
import math
from datetime import datetime, timedelta
import pytz # ç”¨æ–¼è™•ç†æ™‚å€
import re # ç”¨æ–¼æ­£è¦è¡¨é”å¼
import asyncio # ç”¨æ–¼éåŒæ­¥æ“ä½œ

# --- é…ç½®å€å¡Š ---
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')

# å¹£å®‰ API ç«¯é» (é€šå¸¸ä¸éœ€è¦ä¿®æ”¹)
BINANCE_FUTURES_EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo"
BINANCE_FUTURES_OPEN_INTEREST_URL = "https://fapi.binance.com/fapi/v1/openInterest"
BINANCE_SPOT_MINITICKER_URL = "https://api.binance.com/api/v3/ticker/24hr" 

# åƒ¹æ ¼è®Šå‹•è©•ç´šé–¾å€¼ (ä¸è®Š)
PRICE_TIERS = [
    {"threshold": 5.0, "rating": "â­â­â­â­"},
    {"threshold": 4.0, "rating": "â­â­â­"},
    {"threshold": 3.0, "rating": "â­â­"},
    {"threshold": 2.0, "rating": "â­"}
]

# æŒå€‰é‡è®Šå‹•è©•ç´šé–¾å€¼ (ä¸è®Š)
OI_TIERS = [
    {"threshold": 5.0, "rating": "ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥"},
    {"threshold": 3.5, "rating": "ğŸ”¥ğŸ”¥ğŸ”¥"},
    {"threshold": 3.0, "rating": "ğŸ”¥ğŸ”¥"},
    {"threshold": 2.5, "rating": "ğŸ”¥"}
]

# è­¦å ±å†·å»æ™‚é–“ (åˆ†é˜)
ALERT_COOLDOWN_MINUTES = 5

# æ•¸æ“šå„²å­˜ (çµæ§‹ä¸è®Š)
history_data = {}
monitored_symbols = [] 

# IP å°é–ç‹€æ…‹è¿½è¹¤
is_ip_banned = False
ban_until = None 

# --- è¼”åŠ©å‡½æ•¸ ---

def calculate_percentage_change(data_array, minutes):
    """
    è¨ˆç®—æ•¸æ“šé™£åˆ—åœ¨æŒ‡å®šåˆ†é˜å…§çš„ç™¾åˆ†æ¯”è®Šå‹•ã€‚
    """
    if not data_array or len(data_array) < 2:
        return None

    now = datetime.now(pytz.utc)
    cutoff_time = now - timedelta(minutes=minutes)

    old_val = None
    for item in reversed(data_array):
        if item['timestamp'] <= cutoff_time:
            old_val = item['value']
            break
    
    if old_val is None: # å¦‚æœæ‰¾ä¸åˆ°è¶³å¤ èˆŠçš„æ•¸æ“šé»
        return None

    new_val = data_array[-1]['value']

    if new_val is None or old_val == 0:
        return None

    return ((new_val - old_val) / old_val) * 100

def get_rating_info(value, tiers):
    """
    æ ¹æ“šå€¼å’Œå®šç¾©çš„è©•ç´šå±¤ç´šç²å–è©•ç´šç¬¦è™Ÿã€‚
    """
    abs_value = abs(value)
    for tier in tiers:
        if abs_value >= tier["threshold"]:
            return tier["rating"]
    return ""

def format_large_number(num):
    """
    å°‡å¤§æ•¸å­—æ ¼å¼åŒ–ç‚ºå¸¶æœ‰ K/M/B å–®ä½å’Œå…©ä½å°æ•¸çš„å­—ä¸²ã€‚
    """
    if num is None or math.isnan(num):
        return 'N/A'
    if num >= 1_000_000_000:
        return f"{(num / 1_000_000_000):.2f}B"
    elif num >= 1_000_000:
        return f"{(num / 1_000_000):.2f}M" # å·²ä¿®æ­£ï¼šé€™è£¡ä¸å†æœ‰å¤šé¤˜çš„'f'
    elif num >= 1_000:
        return f"{(num / 1_000):.2f}K"
    else:
        return f"{num:.2f}"

def format_pct_or_na(value):
    """
    å°‡æ•¸å­—æ ¼å¼åŒ–ç‚ºå¸¶æœ‰å…©ä½å°æ•¸çš„ç™¾åˆ†æ¯”å­—ä¸²ï¼Œå¦‚æœç‚º None æˆ– NaN å‰‡è¿”å› 'N/A'ã€‚
    """
    if value is None or math.isnan(value):
        return 'N/A'
    return f"{value:.2f}%"

# ç°¡åŒ– Telegram è¨Šæ¯ç™¼é€çš„ print
async def send_telegram_alert(message):
    """
    é€é Telegram Bot ç™¼é€è¨Šæ¯ã€‚
    """
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("ERROR: Telegram BOT_TOKEN æˆ– CHAT_ID æœªé…ç½®ã€‚ç„¡æ³•ç™¼é€è¨Šæ¯ã€‚")
        return

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': message,
        'parse_mode': 'HTML' 
    }
    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status() 
        # print(f"DEBUG: Telegram è¨Šæ¯ç™¼é€æˆåŠŸ: {message.splitlines()[0]}") # æ¸›å°‘é‡è¤‡æ—¥èªŒ
    except requests.exceptions.HTTPError as e:
        print(f"ERROR: ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: HTTP éŒ¯èª¤ {e.response.status_code} - {e.response.text}")
    except requests.exceptions.RequestException as e:
        print(f"ERROR: ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: ç¶²è·¯éŒ¯èª¤ - {e}")
    except Exception as e:
        print(f"CRITICAL: ç™¼é€ Telegram è¨Šæ¯æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")


def retry_fetch(url, retries=3, delay=1):
    """
    å¸¶æœ‰é‡è©¦é‚è¼¯çš„ fetch è«‹æ±‚ï¼Œä¸¦è™•ç†å¹£å®‰çš„ IP å°é–ã€‚
    """
    global is_ip_banned, ban_until 
    for i in range(retries):
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status() 
            is_ip_banned = False 
            ban_until = None
            return response.json()
        except requests.exceptions.HTTPError as e:
            error_text = e.response.text
            print(f"WARNING: ç¬¬ {i + 1} æ¬¡ç²å–å¤±æ•—: {url}, Status: {e.response.status_code}")

            if e.response.status_code in [418, 429] or ("-1003" in error_text and "banned" in error_text):
                is_ip_banned = True
                ban_match = re.search(r"banned until (\d+)", error_text)
                if ban_match:
                    ban_timestamp_ms = int(ban_match.group(1))
                    ban_until = datetime.fromtimestamp(ban_timestamp_ms / 1000, tz=pytz.utc)
                    print(f"CRITICAL: IP å·²è¢«å¹£å®‰å°é–ï¼Œç›´åˆ°: {ban_until.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                else:
                    ban_until = datetime.now(pytz.utc) + timedelta(minutes=5)
                    print("CRITICAL: IP å·²è¢«å¹£å®‰å°é– (æœªæä¾›å…·é«”æ™‚é–“)ï¼Œå‡å®šå°é– 5 åˆ†é˜ã€‚")

                raise Exception(f"IP BANNED: {error_text}")
            else:
                if i < retries - 1:
                    wait_time = delay * (2 ** i)
                    print(f"INFO: å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                    time.sleep(wait_time)
                else:
                    raise e 
        except requests.exceptions.RequestException as e:
            print(f"ERROR: ç¬¬ {i + 1} æ¬¡ç²å–ç¶²è·¯éŒ¯èª¤: {url}: {e}")
            if i < retries - 1:
                wait_time = delay * (2 ** i)
                print(f"INFO: å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                time.sleep(wait_time)
            else:
                raise e

    raise Exception(f"CRITICAL: åœ¨ {retries} æ¬¡é‡è©¦å¾Œï¼Œä»ç„¡æ³•ç²å– {url}ã€‚")

# --- æ•¸æ“šç²å–å’Œè™•ç† ---

def initialize_monitoring_symbols():
    """
    å‹•æ…‹ç²å–ä¸¦è¨­å®šè¦ç›£æ§çš„äº¤æ˜“å°åˆ—è¡¨ã€‚
    """
    global monitored_symbols, history_data, is_ip_banned, ban_until

    print("INFO: æ­£åœ¨ç²å–å¯ç›£æ§çš„æœŸè²¨äº¤æ˜“å°åˆ—è¡¨...")
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
        print(f"WARNING: IP ä»ç„¶è¢«å°é–ï¼Œå‰©é¤˜ {remaining_time:.0f} ç§’ã€‚è·³éäº¤æ˜“å°åˆå§‹åŒ–ã€‚")
        return False

    is_ip_banned = False

    try:
        response_data = retry_fetch(BINANCE_FUTURES_EXCHANGE_INFO_URL)
        valid_symbols = [
            s['symbol'].replace('USDT', '/USDT')
            for s in response_data['symbols']
            if s['quoteAsset'] == 'USDT' and s['contractType'] == 'PERPETUAL' and s['status'] == 'TRADING'
        ]

        monitored_symbols = valid_symbols

        new_history_data = {}
        for symbol in monitored_symbols:
            if symbol in history_data:
                new_history_data[symbol] = history_data[symbol]
            else:
                new_history_data[symbol] = {
                    'spot': [],
                    'futures': [],
                    'last_alert_time': None,
                    'first_alert_time': None,
                    'subsequent_alert_times': []
                }
        history_data = new_history_data

        print(f"INFO: å·²è¼‰å…¥ {len(monitored_symbols)} å€‹æœŸè²¨äº¤æ˜“å°ã€‚")
        if not monitored_symbols:
            print("WARNING: æ²’æœ‰æ‰¾åˆ°å¯ç›£æ§çš„äº¤æ˜“å°ã€‚")
            return False
        return True

    except Exception as e:
        print(f"ERROR: ç²å–æœŸè²¨äº¤æ˜“å°åˆ—è¡¨å¤±æ•—: {e}")
        return False

def fetch_spot_prices():
    """
    ç²å–æ‰€æœ‰ç›£æ§äº¤æ˜“å°çš„ç•¶å‰ç¾è²¨åƒ¹æ ¼ã€‚
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    try:
        all_tickers = retry_fetch(BINANCE_SPOT_MINITICKER_URL)
        now = datetime.now(pytz.utc)

        for ticker in all_tickers:
            symbol_raw = ticker['symbol']
            formatted_symbol = symbol_raw.replace('USDT', '/USDT')
            price = float(ticker['lastPrice'])

            if formatted_symbol in monitored_symbols:
                if formatted_symbol not in history_data:
                    history_data[formatted_symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
                history_data[formatted_symbol]['spot'].append({'timestamp': now, 'value': price})

                cutoff = now - timedelta(minutes=16)
                while history_data[formatted_symbol]['spot'] and history_data[formatted_symbol]['spot'][0]['timestamp'] < cutoff:
                    history_data[formatted_symbol]['spot'].pop(0)

    except Exception as e:
        print(f"ERROR: ç²å–ç¾è²¨åƒ¹æ ¼å¤±æ•—: {e}")


def fetch_open_interest_rest():
    """
    ç²å–æ¯å€‹ç›£æ§äº¤æ˜“å°çš„æœŸè²¨æŒå€‰é‡æ•¸æ“šã€‚
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    delay_between_requests = 0.5 

    for symbol in list(monitored_symbols):
        binance_symbol = symbol.replace('/', '')
        url = f"{BINANCE_FUTURES_OPEN_INTEREST_URL}?symbol={binance_symbol}"
        try:
            data = retry_fetch(url)
            open_interest = float(data['openInterest'])
            now = datetime.now(pytz.utc)

            if symbol not in history_data:
                history_data[symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
            history_data[symbol]['futures'].append({'timestamp': now, 'value': open_interest})

            cutoff = now - timedelta(minutes=16)
            while history_data[symbol]['futures'] and history_data[symbol]['futures'][0]['timestamp'] < cutoff:
                history_data[symbol]['futures'].pop(0)

        except Exception as e:
            print(f"ERROR: ç²å– {symbol} æŒå€‰é‡å¤±æ•—: {e}")
            if "IP BANNED" in str(e):
                return
            if "-4108" in str(e) and "Symbol is on delivering" in str(e):
                print(f"WARNING: äº¤æ˜“å° {symbol} ç‹€æ…‹ç„¡æ•ˆï¼Œå°‡å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ã€‚")
                monitored_symbols.remove(symbol)
                if symbol in history_data:
                    del history_data[symbol]
        finally:
            time.sleep(delay_between_requests)

def check_and_send_alerts():
    """
    æª¢æŸ¥æ˜¯å¦æœ‰é¡¯è‘—çš„åƒ¹æ ¼/æŒå€‰é‡è®Šå‹•ï¼Œä¸¦ç™¼é€ Telegram è­¦å ±ã€‚
    """
    global history_data
    now = datetime.now(pytz.utc)

    for symbol in list(monitored_symbols):
        if symbol not in history_data:
            continue

        spot_hist = history_data[symbol]['spot']
        fut_hist = history_data[symbol]['futures']

        p1 = calculate_percentage_change(spot_hist, 1)
        p5 = calculate_percentage_change(spot_hist, 5)
        p15 = calculate_percentage_change(spot_hist, 15)

        o1 = calculate_percentage_change(fut_hist, 1)
        o5 = calculate_percentage_change(fut_hist, 5)
        o15 = calculate_percentage_change(fut_hist, 15)

        price_rating = get_rating_info(max(abs(p1) if p1 is not None else 0, abs(p5) if p5 is not None else 0, abs(p15) if p15 is not None else 0), PRICE_TIERS)
        oi_rating = get_rating_info(max(abs(o1) if o1 is not None else 0, abs(o5) if o5 is not None else 0, abs(o15) if o15 is not None else 0), OI_TIERS)

        price_alert_threshold_met = (
            (p1 is not None and abs(p1) >= PRICE_TIERS[-1]["threshold"]) or
            (p5 is not None and abs(p5) >= PRICE_TIERS[-1]["threshold"]) or
            (p15 is not None and abs(p15) >= PRICE_TIERS[-1]["threshold"])
        )

        oi_alert_threshold_met = (
            (o1 is not None and abs(o1) >= OI_TIERS[-1]["threshold"]) or
            (o5 is not None and abs(o5) >= OI_TIERS[-1]["threshold"]) or
            (o15 is not None and abs(o15) >= OI_TIERS[-1]["threshold"])
        )

        last_alert_time = history_data[symbol]['last_alert_time']
        if last_alert_time and (now - last_alert_time).total_seconds() / 60 < ALERT_COOLDOWN_MINUTES:
            continue

        alert_message_parts = []
        is_alert_triggered = False

        if price_alert_threshold_met:
            price_alert_message = (
                f"ğŸ“ˆ <b>åƒ¹æ ¼ç•°å‹• {price_rating}è©•ç´š - #{symbol}:</b>\n"
                f"â€¢ 1m: {format_pct_or_na(p1)} | 5m: {format_pct_or_na(p5)} | 15m: {format_pct_or_na(p15)}"
            )
            alert_message_parts.append(price_alert_message)
            is_alert_triggered = True

        if oi_alert_threshold_met:
            note = ""
            has_bearish_oi_increase = False
            if p1 is not None and o1 is not None and p1 < 0 and o1 > 0:
                has_bearish_oi_increase = True
            if p5 is not None and o5 is not None and p5 < 0 and o5 > 0:
                has_bearish_oi_increase = True
            if p15 is not None and o15 is not None and p15 < 0 and o15 > 0:
                has_bearish_oi_increase = True

            if has_bearish_oi_increase:
                note = " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"

            oi_alert_message = (
                f"ğŸ’¹ <b>æŒå€‰ç•°å‹• {oi_rating}{note} - #{symbol}:</b>\n"
                f"â€¢ 1m: {format_pct_or_na(o1)} | 5m: {format_pct_or_na(o5)} | 15m: {format_pct_or_na(o15)}"
            )
            alert_message_parts.append(oi_alert_message)
            is_alert_triggered = True
        
        if is_alert_triggered:
            if history_data[symbol]['first_alert_time'] is None:
                history_data[symbol]['first_alert_time'] = now
                history_data[symbol]['subsequent_alert_times'] = []
            else:
                history_data[symbol]['subsequent_alert_times'].append(now)

            # ç°¡åŒ–æ™‚é–“æˆ³æ ¼å¼ï¼Œé¿å…ä¸­æ–‡
            first_alert_str = history_data[symbol]['first_alert_time'].strftime("%Y-%m-%d %H:%M:%S UTC")
            timestamp_info = f"\né¦–æ¬¡è§¸ç™¼æ™‚é–“: {first_alert_str}"
            
            if history_data[symbol]['subsequent_alert_times']:
                last_subsequent_str = history_data[symbol]['subsequent_alert_times'][-1].strftime("%Y-%m-%d %H:%M:%S UTC")
                timestamp_info += f"\nä¸Šæ¬¡è§¸ç™¼æ™‚é–“: {last_subsequent_str}"

            final_alert_message = "\n\n".join(alert_message_parts) + timestamp_info
            
            asyncio.run(send_telegram_alert(final_alert_message))
            history_data[symbol]['last_alert_time'] = now

# --- ä¸»æ‡‰ç”¨ç¨‹å¼å¾ªç’° ---

async def main_loop():
    """
    ä¸»è¦å¾ªç’°ï¼Œè² è²¬ç²å–æ•¸æ“šå’Œæª¢æŸ¥è­¦å ±ã€‚
    """
    global is_ip_banned, ban_until

    start_message = "Ashdataæƒéˆç¨‹å¼å·²å•Ÿå‹•ï¼æ­£åœ¨åˆå§‹åŒ–äº¤æ˜“å°åˆ—è¡¨..."
    print(f"INFO: å˜—è©¦ç™¼é€å•Ÿå‹•è¨Šæ¯: {start_message}")
    try:
        await send_telegram_alert(start_message)
    except Exception as e:
        print(f"ERROR: å•Ÿå‹•è¨Šæ¯ç™¼é€å¤±æ•—: {e}")

    init_success = False
    while not init_success:
        init_success = initialize_monitoring_symbols()
        if not init_success:
            print("WARNING: åˆå§‹åŒ–äº¤æ˜“å°å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
            try:
                await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚")
            except:
                pass
            await asyncio.sleep(60)

    startup_complete_message = f"Ashdataæƒéˆå·²åµæ¸¬åˆ° <b>{len(monitored_symbols)}</b> ç¨®æ¨™çš„ã€‚ç›£æ§æœå‹™æ­£å¼å•Ÿå‹•ï¼"
    print(f"INFO: å˜—è©¦ç™¼é€å•Ÿå‹•å®Œæˆè¨Šæ¯: {startup_complete_message}")
    try:
        await send_telegram_alert(startup_complete_message)
    except Exception as e:
        print(f"ERROR: å•Ÿå‹•å®Œæˆè¨Šæ¯ç™¼é€å¤±æ•—: {e}")

    while True:
        if is_ip_banned:
            if ban_until and datetime.now(pytz.utc) < ban_until:
                remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
                print(f"WARNING: IP ä»ç„¶è¢«å°é–ã€‚å°‡ç­‰å¾… {remaining_time:.0f} ç§’å¾Œé‡è©¦æ‰€æœ‰æ•¸æ“šç²å–ã€‚")
                try:
                    await send_telegram_alert(f"âš ï¸ è­¦å ±ï¼šAshdataæƒéˆIPå·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œå‰©é¤˜ç´„ {remaining_time:.0f} ç§’ã€‚")
                except:
                    pass
                await asyncio.sleep(max(10, remaining_time + 5))
                continue
            else:
                print("INFO: IP å°é–å¯èƒ½å·²è§£é™¤ã€‚æ­£åœ¨å˜—è©¦æ¸…é™¤å°é–ç‹€æ…‹ä¸¦é‡æ–°åˆå§‹åŒ–ã€‚")
                is_ip_banned = False
                ban_until = None
                init_success = initialize_monitoring_symbols()
                if not init_success:
                    print("WARNING: è§£é™¤å°é–å¾Œçš„é‡æ–°åˆå§‹åŒ–å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
                    try:
                        await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆè§£é™¤IPå°é–å¾Œåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚")
                    except:
                        pass
                    await asyncio.sleep(60)
                    continue

        print("INFO: é–‹å§‹ç²å–ç¾è²¨åƒ¹æ ¼å’ŒæœŸè²¨æŒå€‰é‡...")
        fetch_spot_prices()
        fetch_open_interest_rest()
        print("INFO: å®Œæˆæ•¸æ“šç²å–ã€‚")

        print("INFO: æª¢æŸ¥ä¸¦ç™¼é€è­¦å ±...")
        check_and_send_alerts()
        print("INFO: è­¦å ±æª¢æŸ¥å®Œæˆã€‚")

        min_fetch_interval = 60
        calculated_fetch_interval = len(monitored_symbols) * 0.5 + 10
        next_interval = max(min_fetch_interval, calculated_fetch_interval)
        
        print(f"INFO: ä¸‹ä¸€æ¬¡æ•¸æ“šç²å–å’Œè­¦å ±æª¢æŸ¥å°‡åœ¨ {next_interval:.0f} ç§’å¾Œé€²è¡Œ...")
        await asyncio.sleep(next_interval)

if __name__ == "__main__":
    asyncio.run(main_loop())
