import os
import sys
import time
import logging
import requests

# ========== 載入環境變數 ==========
from datetime import datetime, timedelta
from dotenv import load_dotenv
from collections import deque 
load_dotenv()
try:
    import ccxt
except ImportError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt
# ========== 設定 logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== 參數設定 ==========

# ========== 載入環境變數 ==========
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')
# 確認 Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN 或 TELEGRAM_CHAT_ID 未設定！請檢查 .env 檔")
    sys.exit(1)

# ========== 初始化交易所 ==========
# ========== 初始化交易所並預載市場 ==========
exchanges = {
    name: getattr(ccxt, name)({'enableRateLimit': True})
    for name in ['binance','bybit','okx','bitget','mexc','gateio']
}
binance_futures = ccxt.binance({
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})
#####################################
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # 轉成 ccxt 格式（BTCUSDT -> BTC/USDT）
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        print(f"requests 取得 Binance 期貨交易對失敗: {e}")
        return []

symbols = get_binance_futures_symbols_via_requests()

############################
# 載入所有 markets，保證 .markets 可用
binance_futures.load_markets()
for ex in exchanges.values():
    try:
        ex.load_markets()
    except Exception as e:
        logging.warning(f"{ex.id} load_markets 失敗: {e}")
# ========== 取得 Binance 期貨 USDT 合約列表 ==========
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        syms = [
            s['symbol'] for s in data['symbols']
            if s['quoteAsset']=='USDT'
            and s['contractType'] in ('PERPETUAL','CURRENT_QUARTER','NEXT_QUARTER')
        ]
        return [s.replace('USDT','/USDT') for s in syms]
    except Exception as e:
        logging.error(f"requests 取得期貨交易對失敗: {e}")
        return []
# ========== 發送警報 ==========
# ========== 發送 Telegram 警報 ==========
def send_alert(message: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
    try:
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            logging.warning(f"Telegram 發送失敗: {r.text}")
    except Exception as e:
        logging.error(f"Telegram 發送異常: {e}")
# ========== 閾值設定 ==========
PRICE_TIERS = [(5.0,'⭐⭐⭐⭐'),(4.0,'⭐⭐⭐'),(3.0,'⭐⭐'),(2.0,'⭐')]
OI_TIERS    = [(5.0,'🔥🔥🔥🔥'),(3.5,'🔥🔥🔥'),(3.0,'🔥🔥'),(2.5,'🔥')]

# ========== 格式化並發送報文 ==========
# ========== 格式化並發送報文 ==========
def format_and_send(symbol, spot_hist, fut_hist, best_ex_id, timeframe):
    # 計算百分比變動
    def pct(arr, mins):
        cutoff = datetime.utcnow() - timedelta(minutes=mins)
        old = next((v for (t, v) in arr if t <= cutoff), None)
        new = arr[-1][1] if arr else None
        return ((new - old) / old * 100) if (old and new is not None) else 0.0

    p1, p5, p15 = pct(spot_hist, 1), pct(spot_hist, 5), pct(spot_hist, 15)
    o1, o5, o15 = pct(fut_hist, 1), pct(fut_hist, 5), pct(fut_hist, 15)

    price_alert = max(abs(p1), abs(p5), abs(p15)) >= PRICE_TIERS[-1][0]
    oi_alert    = max(abs(o1), abs(o5), abs(o15)) >= OI_TIERS[-1][0]
    if not price_alert and not oi_alert:
        return

    # 1️⃣ 第一段：標題
    if price_alert:
        stars = next(r for th, r in PRICE_TIERS if abs(p1) >= th or abs(p5) >= th or abs(p15) >= th)
        header = f"📈 價格異動 {stars}評級"
    else:
        fires = next(r for th, r in OI_TIERS if abs(o1) >= th or abs(o5) >= th or abs(o15) >= th)
        cor   = (p1 * o1 > 0 and p5 * o5 > 0 and p15 * o15 > 0)
        note  = "" if cor else " ⚠️疑是空方進場"
        header = f"💹 持倉異動 {fires}{note}"

    # 2️⃣ 第二段：交易所 + 交易對
    pair_line = f"{best_ex_id}:{symbol.replace('/', '')}"

    # 3️⃣ 第三段：Timeframe
    tf_line = f"Timeframe: {timeframe}"

    # 細節行
    lines = [header, pair_line, tf_line]
    if price_alert:
        lines.append(f" • 1m: {p1:+.2f}% 5m: {p5:+.2f}% 15m: {p15:+.2f}%")
    if oi_alert:
        lines.append(f" • 1m: {o1:+.2f}% 5m: {o5:+.2f}% 15m: {o15:+.2f}%")

    lines.append(f"時間：{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}")
    send_alert("\n".join(lines))

# ========== 歷史資料儲存 ==========
history = {}  # {symbol: {'spot': [(timestamp, price, volume)], 'futures': [(timestamp, open_interest)]}}

# ========== 主循環 ==========
# ========== 主程式 ==========
def main():
    all_syms = get_binance_futures_symbols_via_requests()
    if not all_syms:
        logging.error("無期貨合約可監控，程式結束")
        return

    # 過濾出至少一個現貨交易所支援的合約
    potential_syms = []
    for sym in all_syms:
        spot_sym = f"{sym.split('/')[0]}/USDT"
        if any(spot_sym in ex.markets for ex in exchanges.values()):
            potential_syms.append(sym)
        else:
            logging.info(f"{sym} 無現貨市場支援，跳過")

    if not potential_syms:
        logging.error("經過過濾後，沒有任何可監控的合約")
        return

    # 先發潛在名單前 20 筆到 Telegram
    sample = potential_syms[:20]
    notice = (
        f"🛰️ Ashdata 潛在監控名單（示例前20筆，共{len(potential_syms)}）：\n"
        + "\n".join(sample)
    )
    logging.info(notice)
    send_alert(notice)

    # 啟動通知
    init_msg = f"🛰️ Ashdata監控啟動：共偵測到 {len(potential_syms)} 個可監控合約"
    logging.info(init_msg)
    send_alert(init_msg)

    # 建立歷史資料結構
    history = {s: {'spot': deque(), 'futures': deque()} for s in potential_syms}

    while True:
        start = time.time()
        for symbol in potential_syms:
            base     = symbol.split('/')[0]
            spot_sym = f"{base}/USDT"

            # 選成交量最大現貨交易所
            best_ex, maxv = None, 0.0
            for ex in exchanges.values():
                if spot_sym not in ex.markets:
                    continue
                try:
                    vol = ex.fetch_ticker(spot_sym).get('quoteVolume', 0) or 0
                    if vol > maxv:
                        best_ex, maxv = ex, vol
                except:
                    continue
            if not best_ex:
                continue

            # 抓 1 分鐘 OHLCV 收盤價
            try:
                ohlcv = best_ex.fetch_ohlcv(spot_sym, '1m', limit=2)
                prev, curr = ohlcv[-2][4], ohlcv[-1][4]
            except:
                continue

            # 抓期貨持倉量
            try:
                curr_oi = float(binance_futures.fetch_open_interest(symbol)['openInterest'])
            except:
                continue

            now = datetime.utcnow()
            sh, fh = history[symbol]['spot'], history[symbol]['futures']
            sh.append((now, curr))
            fh.append((now, curr_oi))

            # 保留最近 15 分鐘資料
            cutoff = now - timedelta(minutes=15)
            history[symbol]['spot']   = [(t, v) for t, v in sh if t >= cutoff]
            history[symbol]['futures'] = [(t, v) for t, v in fh if t >= cutoff]

            # 格式化並發送警報
            format_and_send(symbol, history[symbol]['spot'],
                            history[symbol]['futures'],
                            best_ex.id, '1m')

            time.sleep(0.2)

        elapsed = time.time() - start
        if elapsed < 60:
            time.sleep(60 - elapsed)

if __name__ == "__main__":
    main()
