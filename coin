import os
import time
import requests
import json
import math
import re
import asyncio
import threading
from datetime import datetime, timedelta
import pytz 

from flask import Flask, jsonify, render_template

# --- é…ç½®å€å¡Š ---
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')

# å¹£å®‰ API ç«¯é»
BINANCE_FUTURES_EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo"
BINANCE_FUTURES_OPEN_INTEREST_URL = "https://fapi.binance.com/fapi/v1/openInterest"
BINANCE_SPOT_TICKER_URL = "https://api.binance.com/api/v3/ticker/24hr" 

# è­¦å ±é–¾å€¼ (å¾ä½ çš„ç¶²é ç‰ˆç¨‹å¼ç¢¼ä¸­æå–)
PRICE_ALERT_THRESHOLD = 2.0  
OI_ALERT_THRESHOLD = 2.5     

# è­¦å ±å†·å»æ™‚é–“ (åˆ†é˜)
ALERT_COOLDOWN_MINUTES = 5

# --- å…¨åŸŸæ•¸æ“šå„²å­˜ (ç”±å¾Œå°ä»»å‹™æ›´æ–°ï¼Œç”± API è®€å–) ---
monitored_data = {} 
monitored_symbols = [] 
is_ip_banned = False
ban_until = None 
alerts_to_display = [] # ç”¨æ–¼è¨˜éŒ„ç™¼é€åˆ° Telegram çš„è­¦å ±ï¼Œæ–¹ä¾¿ API æŸ¥è©¢

# --- è¼”åŠ©å‡½æ•¸ ---

def get_utc_now():
    return datetime.now(pytz.utc)

def calculate_percentage_change(data_array, minutes):
    if not data_array or len(data_array) < 2: 
        return None
    cutoff_time = get_utc_now() - timedelta(minutes=minutes)
    old_val = None
    for item in reversed(data_array):
        if item['timestamp'] <= cutoff_time:
            old_val = item['value']
            break
    if old_val is None or old_val == 0:
        return None
    new_val = data_array[-1]['value']
    if new_val is None:
        return None
    return ((new_val - old_val) / old_val) * 100

def format_pct_or_na(value):
    if value is None or math.isnan(value):
        return 'N/A'
    return f"{value:.2f}%"

async def send_telegram_alert(message):
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        app.logger.error("Telegram BOT_TOKEN æˆ– CHAT_ID æœªé…ç½®ã€‚ç„¡æ³•ç™¼é€è¨Šæ¯ã€‚")
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message, 'parse_mode': 'HTML'}
    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status() 
        app.logger.info(f"Telegram è¨Šæ¯ç™¼é€æˆåŠŸ: {message.splitlines()[0]}")
        
        # å°‡è­¦å ±å­˜å„²åˆ°åˆ—è¡¨ï¼Œä»¥ä¾¿å‰ç«¯èª¿ç”¨
        alerts_to_display.append({
            'message': message,
            'timestamp': get_utc_now().strftime("%Y-%m-%d %H:%M:%S UTC")
        })
        if len(alerts_to_display) > 20: # åªä¿ç•™æœ€è¿‘20æ¢è­¦å ±
            alerts_to_display.pop(0)

    except requests.exceptions.HTTPError as e:
        app.logger.error(f"ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: HTTP éŒ¯èª¤ {e.response.status_code} - {e.response.text}")
    except requests.exceptions.RequestException as e:
        app.logger.error(f"ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: ç¶²è·¯éŒ¯èª¤ - {e}")
    except Exception as e:
        app.logger.critical(f"ç™¼é€ Telegram è¨Šæ¯æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")

async def retry_fetch(url, retries=3, delay=1):
    global is_ip_banned, ban_until 
    for i in range(retries):
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status() 
            is_ip_banned = False 
            ban_until = None
            return response.json()
        except requests.exceptions.HTTPError as e:
            error_text = e.response.text
            app.logger.warning(f"ç¬¬ {i + 1} æ¬¡ç²å–å¤±æ•—: {url}, Status: {e.response.status_code}")
            if e.response.status_code in [418, 429] or ("-1003" in error_text and "banned" in error_text):
                is_ip_banned = True
                ban_match = re.search(r"banned until (\d+)", error_text)
                if ban_match:
                    ban_timestamp_ms = int(ban_match.group(1))
                    ban_until = datetime.fromtimestamp(ban_timestamp_ms / 1000, tz=pytz.utc)
                    app.logger.critical(f"IP å·²è¢«å¹£å®‰å°é–ï¼Œç›´åˆ°: {ban_until.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                else:
                    ban_until = get_utc_now() + timedelta(minutes=5)
                    app.logger.critical("IP å·²è¢«å¹£å®‰å°é– (æœªæä¾›å…·é«”æ™‚é–“)ï¼Œå‡å®šå°é– 5 åˆ†é˜ã€‚")
                raise Exception(f"IP BANNED: {error_text}")
            else:
                if i < retries - 1:
                    wait_time = delay * (2 ** i)
                    app.logger.info(f"å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                    await asyncio.sleep(wait_time)
                else:
                    raise e 
        except requests.exceptions.RequestException as e:
            app.logger.error(f"ç¬¬ {i + 1} æ¬¡ç²å–ç¶²è·¯éŒ¯èª¤: {url}: {e}")
            if i < retries - 1:
                wait_time = delay * (2 ** i)
                app.logger.info(f"å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                await asyncio.sleep(wait_time)
            else:
                raise e
    raise Exception(f"CRITICAL: åœ¨ {retries} æ¬¡é‡è©¦å¾Œï¼Œä»ç„¡æ³•ç²å– {url}ã€‚")


async def initialize_monitoring_symbols():
    global monitored_symbols, monitored_data, is_ip_banned, ban_until
    app.logger.info("æ­£åœ¨ç²å–å¯ç›£æ§çš„æœŸè²¨äº¤æ˜“å°åˆ—è¡¨...")
    if is_ip_banned and ban_until and get_utc_now() < ban_until:
        return False
    is_ip_banned = False
    try:
        response_data = await retry_fetch(BINANCE_FUTURES_EXCHANGE_INFO_URL)
        valid_symbols = [s['symbol'].replace('USDT', '/USDT') for s in response_data['symbols'] if s['quoteAsset'] == 'USDT' and s['contractType'] == 'PERPETUAL' and s['status'] == 'TRADING']
        monitored_symbols = valid_symbols
        new_monitored_data = {}
        for symbol in monitored_symbols:
            if symbol in monitored_data: 
                new_monitored_data[symbol] = monitored_data[symbol]
            else:
                new_monitored_data[symbol] = {
                    'spot_history': [], 'futures_history': [], 
                    'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': [],
                    'latest_price': None, 'latest_oi': None, 
                    'price_changes': {'1m': 'N/A', '5m': 'N/A', '15m': 'N/A'},
                    'oi_changes': {'1m': 'N/A', '5m': 'N/A', '15m': 'N/A'}
                }
        monitored_data = new_monitored_data
        app.logger.info(f"å·²è¼‰å…¥ {len(monitored_symbols)} å€‹æœŸè²¨äº¤æ˜“å°ã€‚")
        if not monitored_symbols:
            app.logger.warning("æ²’æœ‰æ‰¾åˆ°å¯ç›£æ§çš„äº¤æ˜“å°ã€‚")
            return False
        return True
    except Exception as e:
        app.logger.error(f"ç²å–æœŸè²¨äº¤æ˜“å°åˆ—è¡¨å¤±æ•—: {e}")
        return False

async def fetch_spot_prices():
    global monitored_data
    if is_ip_banned and ban_until and get_utc_now() < ban_until:
        return
    try:
        all_tickers = await retry_fetch(BINANCE_SPOT_TICKER_URL)
        now = get_utc_now()
        for ticker in all_tickers:
            symbol_raw = ticker['symbol']
            formatted_symbol = symbol_raw.replace('USDT', '/USDT')
            price = float(ticker['lastPrice'])
            if formatted_symbol in monitored_data:
                monitored_data[formatted_symbol]['latest_price'] = price
                monitored_data[formatted_symbol]['spot_history'].append({'timestamp': now, 'value': price})
                cutoff = now - timedelta(minutes=16)
                while monitored_data[formatted_symbol]['spot_history'] and monitored_data[formatted_symbol]['spot_history'][0]['timestamp'] < cutoff:
                    monitored_data[formatted_symbol]['spot_history'].pop(0)
    except Exception as e:
        app.logger.error(f"ç²å–ç¾è²¨åƒ¹æ ¼å¤±æ•—: {e}")

async def fetch_open_interest_rest():
    global monitored_data
    if is_ip_banned and ban_until and get_utc_now() < ban_until:
        return
    delay_between_requests = 0.5 
    for symbol in list(monitored_symbols):
        binance_symbol = symbol.replace('/', '')
        url = f"{BINANCE_FUTURES_OPEN_INTEREST_URL}?symbol={binance_symbol}"
        try:
            data = await retry_fetch(url)
            open_interest = float(data['openInterest'])
            now = get_utc_now()
            if symbol in monitored_data:
                monitored_data[symbol]['latest_oi'] = open_interest
                monitored_data[symbol]['futures_history'].append({'timestamp': now, 'value': open_interest})
                cutoff = now - timedelta(minutes=16)
                while monitored_data[symbol]['futures_history'] and monitored_data[symbol]['futures_history'][0]['timestamp'] < cutoff:
                    monitored_data[symbol]['futures_history'].pop(0)
        except Exception as e:
            app.logger.error(f"ç²å– {symbol} æŒå€‰é‡å¤±æ•—: {e}")
            if "IP BANNED" in str(e):
                return
            if "-4108" in str(e) and "Symbol is on delivering" in str(e):
                app.logger.warning(f"äº¤æ˜“å° {symbol} ç‹€æ…‹ç„¡æ•ˆï¼Œå°‡å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ã€‚")
                monitored_symbols.remove(symbol)
                if symbol in monitored_data:
                    del monitored_data[symbol]
        finally:
            await asyncio.sleep(delay_between_requests)

async def check_and_send_alerts():
    global monitored_data
    now = get_utc_now()
    for symbol in list(monitored_symbols):
        if symbol not in monitored_data or 'spot_history' not in monitored_data[symbol] or 'futures_history' not in monitored_data[symbol]:
            continue
        data_entry = monitored_data[symbol]
        spot_hist = data_entry['spot_history']
        fut_hist = data_entry['futures_history']

        p_change_1m = calculate_percentage_change(spot_hist, 1)
        p_change_5m = calculate_percentage_change(spot_hist, 5)
        p_change_15m = calculate_percentage_change(spot_hist, 15)
        data_entry['price_changes'] = {'1m': p_change_1m, '5m': p_change_5m, '15m': p_change_15m}

        oi_change_1m = calculate_percentage_change(fut_hist, 1)
        oi_change_5m = calculate_percentage_change(fut_hist, 5)
        oi_change_15m = calculate_percentage_change(fut_hist, 15)
        data_entry['oi_changes'] = {'1m': oi_change_1m, '5m': oi_change_5m, '15m': oi_change_15m}

        price_alert_triggered = False
        if (p_change_1m is not None and abs(p_change_1m) >= PRICE_ALERT_THRESHOLD) or \
           (p_change_5m is not None and abs(p_change_5m) >= PRICE_ALERT_THRESHOLD) or \
           (p_change_15m is not None and abs(p_change_15m) >= PRICE_ALERT_THRESHOLD):
            price_alert_triggered = True

        oi_alert_triggered = False
        if (oi_change_1m is not None and abs(oi_change_1m) >= OI_ALERT_THRESHOLD) or \
           (oi_change_5m is not None and abs(oi_change_5m) >= OI_ALERT_THRESHOLD) or \
           (oi_change_15m is not None and abs(oi_change_15m) >= OI_ALERT_THRESHOLD):
            oi_alert_triggered = True

        if not (price_alert_triggered or oi_alert_triggered):
            continue
        
        last_alert_time = data_entry['last_alert_time']
        if last_alert_time and (now - last_alert_time).total_seconds() / 60 < ALERT_COOLDOWN_MINUTES:
            app.logger.info(f"ç¬¦è™Ÿ #{symbol} ä»åœ¨å†·å»ä¸­ ({ALERT_COOLDOWN_MINUTES}åˆ†é˜)ï¼Œè·³éæœ¬æ¬¡ Telegram è­¦å ±ã€‚")
            continue

        alert_message_parts = []
        
        if price_alert_triggered:
            price_msg = f"ğŸ“ˆ <b>åƒ¹æ ¼ç•°å‹• - #{symbol}:</b>\n"
            price_msg += f"â€¢ 1m: {format_pct_or_na(p_change_1m)} | "
            price_msg += f"5m: {format_pct_or_na(p_change_5m)} | "
            price_msg += f"15m: {format_pct_or_na(p_change_15m)}"
            alert_message_parts.append(price_msg)

        if oi_alert_triggered:
            note = ""
            has_bearish_oi_increase = False
            if (p_change_1m is not None and oi_change_1m is not None and p_change_1m < 0 and oi_change_1m > 0) or \
               (p_change_5m is not None and oi_change_5m is not None and p_change_5m < 0 and oi_change_5m > 0) or \
               (p_change_15m is not None and oi_change_15m is not None and p_change_15m < 0 and oi_change_15m > 0):
                has_bearish_oi_increase = True
            if has_bearish_oi_increase:
                note = " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"

            oi_msg = f"ğŸ’¹ <b>æŒå€‰ç•°å‹•{note} - #{symbol}:</b>\n"
            oi_msg += f"â€¢ 1m: {format_pct_or_na(oi_change_1m)} | "
            oi_msg += f"5m: {format_pct_or_na(oi_change_5m)} | "
            oi_msg += f"15m: {format_pct_or_na(oi_change_15m)}"
            alert_message_parts.append(oi_msg)
        
        if data_entry['first_alert_time'] is None:
            data_entry['first_alert_time'] = now
            data_entry['subsequent_alert_times'] = []
        else:
            data_entry['subsequent_alert_times'].append(now)

        first_alert_str = data_entry['first_alert_time'].strftime("%Y-%m-%d %H:%M:%S UTC")
        timestamp_info = f"\né¦–æ¬¡è§¸ç™¼æ™‚é–“: {first_alert_str}"
        if data_entry['subsequent_alert_times']:
            last_subsequent_str = data_entry['subsequent_alert_times'][-1].strftime("%Y-%m-%d %H:%M:%S UTC")
            timestamp_info += f"\nä¸Šæ¬¡è§¸ç™¼æ™‚é–“: {last_subsequent_str}"

        final_alert_message = "\n\n".join(alert_message_parts) + timestamp_info
        
        await send_telegram_alert(final_alert_message)
        data_entry['last_alert_time'] = now

async def main_task():
    app.logger.info("å¾Œå°ç›£æ§ä»»å‹™å·²å•Ÿå‹•ï¼")
    start_message = "Ashdataæƒéˆç¨‹å¼å·²å•Ÿå‹•ï¼æ­£åœ¨åˆå§‹åŒ–äº¤æ˜“å°åˆ—è¡¨..."
    try:
        await send_telegram_alert(start_message)
    except Exception as e:
        app.logger.error(f"å•Ÿå‹•è¨Šæ¯ç™¼é€å¤±æ•—: {e}")

    init_success = False
    while not init_success:
        init_success = await initialize_monitoring_symbols()
        if not init_success:
            app.logger.warning("åˆå§‹åŒ–äº¤æ˜“å°å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
            try:
                await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚")
            except:
                pass
            await asyncio.sleep(60)

    startup_complete_message = f"Ashdataæƒéˆå·²åµæ¸¬åˆ° <b>{len(monitored_symbols)}</b> ç¨®æ¨™çš„ã€‚ç›£æ§æœå‹™æ­£å¼å•Ÿå‹•ï¼"
    try:
        await send_telegram_alert(startup_complete_message)
    except Exception as e:
        app.logger.error(f"å•Ÿå‹•å®Œæˆè¨Šæ¯ç™¼é€å¤±æ•—: {e}")

    while True:
        if is_ip_banned:
            if ban_until and get_utc_now() < ban_until:
                remaining_time = (ban_until - get_utc_now()).total_seconds()
                app.logger.warning(f"IP ä»ç„¶è¢«å°é–ã€‚å°‡ç­‰å¾… {remainingTime:.0f} ç§’å¾Œæª¢æŸ¥æ˜¯å¦è§£é™¤å°é–...")
                try:
                    await send_telegram_alert(f"âš ï¸ è­¦å ±ï¼šAshdataæƒéˆIPå·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œå‰©é¤˜ç´„ {remainingTime:.0f} ç§’ã€‚")
                except:
                    pass
                await asyncio.sleep(max(10, remainingTime + 5))
                continue
            else:
                app.logger.info("IP å°é–å¯èƒ½å·²è§£é™¤ã€‚æ­£åœ¨å˜—è©¦æ¸…é™¤å°é–ç‹€æ…‹ä¸¦é‡æ–°åˆå§‹åŒ–ã€‚")
                is_ip_banned = False
                ban_until = None
                init_success = await initialize_monitoring_symbols()
                if not init_success:
                    app.logger.warning("è§£é™¤å°é–å¾Œçš„é‡æ–°åˆå§‹åŒ–å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
                    try:
                        await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆè§£é™¤IPå°é–å¾Œåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚")
                    except:
                        pass
                    await asyncio.sleep(60)
                    continue

        app.logger.info("é–‹å§‹ç²å–ç¾è²¨åƒ¹æ ¼å’ŒæœŸè²¨æŒå€‰é‡...")
        await fetch_spot_prices()
        await fetch_open_interest_rest()
        app.logger.info("å®Œæˆæ•¸æ“šç²å–ã€‚")

        app.logger.info("æª¢æŸ¥ä¸¦ç™¼é€è­¦å ±...")
        await check_and_send_alerts()
        app.logger.info("è­¦å ±æª¢æŸ¥å®Œæˆã€‚")

        min_fetch_interval = 60
        calculated_fetch_interval = len(monitored_symbols) * 0.5 + 10
        next_interval = max(min_fetch_interval, calculated_fetch_interval)
        
        app.logger.info(f"ä¸‹ä¸€æ¬¡æ•¸æ“šç²å–å’Œè­¦å ±æª¢æŸ¥å°‡åœ¨ {next_interval:.0f} ç§’å¾Œé€²è¡Œ...")
        await asyncio.sleep(next_interval)

# --- Flask æ‡‰ç”¨åˆå§‹åŒ– ---
app = Flask(__name__)

# --- Flask è·¯ç”± ---
@app.route('/')
def index():
    return "<p>ç›£è¦–æœå‹™æ­£åœ¨å¾Œå°é‹è¡Œã€‚è«‹æª¢æŸ¥æ‚¨çš„ Telegramã€‚</p>"

@app.route('/api/status')
def get_status():
    if is_ip_banned:
        return jsonify({'status': 'error', 'message': f"IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œç›´åˆ° {ban_until.strftime('%Y-%m-%d %H:%M:%S UTC')}ã€‚"})
    elif not monitored_symbols:
        return jsonify({'status': 'warning', 'message': 'æœªæ‰¾åˆ°å¯ç›£æ§çš„äº¤æ˜“å°æˆ–åˆå§‹åŒ–å¤±æ•—ã€‚'})
    else:
        return jsonify({'status': 'success', 'message': f"ç›£æ§æœå‹™æ­£åœ¨é‹è¡Œä¸­ï¼Œå·²è¼‰å…¥ {len(monitored_symbols)} å€‹äº¤æ˜“å°ã€‚"})

@app.route('/api/alerts')
def get_alerts():
    return jsonify(alerts_to_display)

# --- å•Ÿå‹•å¾Œå°ä»»å‹™ ---
def start_monitoring_in_thread():
    asyncio.run(main_task())

# Flask æ‡‰ç”¨å•Ÿå‹•æ™‚å•Ÿå‹•å¾Œå°ä»»å‹™
if __name__ == '__main__':
    threading.Thread(target=start_monitoring_in_thread, daemon=True).start()
    app.run(host='0.0.0.0', port=5000)
