import os
import sys
import time
import logging
import requests
# ========== 載入環境變數 ==========
from datetime import datetime, timedelta
from dotenv import load_dotenv
load_dotenv()
try:
    import ccxt
except ImportError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt

# ========== 設定 logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== 參數設定 ==========

# ========== 載入環境變數 ==========
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4617157719')
# 確認 Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN 或 TELEGRAM_CHAT_ID 未設定！請檢查 .env 檔")
    sys.exit(1)

# ========== 初始化交易所 ==========
exchanges = {
    'binance': ccxt.binance({'enableRateLimit': True}),
    'bybit': ccxt.bybit({'enableRateLimit': True}),
    'okx': ccxt.okx({'enableRateLimit': True}),
    'bitget': ccxt.bitget({'enableRateLimit': True}),
    'mexc': ccxt.mexc({'enableRateLimit': True}),
    'gate': ccxt.gate({'enableRateLimit': True}),
}

binance_futures = ccxt.binance({
    'options': {'defaultType': 'future'},
    'enableRateLimit': True
})
#####################################
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # 轉成 ccxt 格式（BTCUSDT -> BTC/USDT）
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        print(f"requests 取得 Binance 期貨交易對失敗: {e}")
        return []

symbols = get_binance_futures_symbols_via_requests()

############################
# ========== 直接用 requests 取得 Binance 期貨 USDT 交易對清單 ==========
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # 轉成 ccxt 格式（BTCUSDT -> BTC/USDT）
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        logging.error(f"requests 取得 Binance 期貨交易對失敗: {e}")
        return []

# ========== 發送警報 ==========
# ========== 發送警報 ==========
def send_alert(message):
    tg_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    tg_payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
    try:
        tg_resp = requests.post(tg_url, data=tg_payload, timeout=10)
        if tg_resp.status_code != 200:
            logging.warning(f"Telegram 發送失敗: {tg_resp.text}")
    except Exception as e:
        logging.error(f"Telegram 發送異常: {e}")

# ========== 閾值設定 ==========
PRICE_TIERS = [(5.0,'⭐⭐⭐⭐'),(4.0,'⭐⭐⭐'),(3.0,'⭐⭐'),(2.0,'⭐')]
OI_TIERS    = [(5.0,'🔥🔥🔥🔥'),(3.5,'🔥🔥🔥'),(3.0,'🔥🔥'),(2.5,'🔥')]

# ========== 格式化並發送 ==========
def format_and_send(symbol, spot_hist, fut_hist):
    # spot_hist/fut_hist 為 list of tuples (ts, value)
    def pct(arr, mins):
        # 找距今大約 mins 筆前的數值
        for ts,val in reversed(arr):
            if ts <= datetime.utcnow() - timedelta(minutes=mins): 
                old = val; break
        else:
            return 0.0
        new = arr[-1][1]
        return (new-old)/old*100 if old else 0.0

    p1 = pct(spot_hist, 1);  p5 = pct(spot_hist, 5);  p15 = pct(spot_hist,15)
    o1 = pct(fut_hist, 1);   o5 = pct(fut_hist, 5);   o15 = pct(fut_hist,15)

    price_alert = max(abs(p1),abs(p5),abs(p15))>=PRICE_TIERS[-1][0]
    oi_alert    = max(abs(o1),abs(o5),abs(o15))>=OI_TIERS[-1][0]
    if not price_alert and not oi_alert:
        return

    lines = [f"🛰️ Ashdata標的監控\n交易對：{symbol}"]
    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

    if price_alert:
        stars = next(r for th,r in PRICE_TIERS if abs(p1)>=th or abs(p5)>=th or abs(p15)>=th)
        lines += [
            f"📈 價格異動 {stars}",
            f" • 1m: {p1:+.2f}% 5m: {p5:+.2f}% 15m: {p15:+.2f}%"
        ]

    if oi_alert:
        fires = next(r for th,r in OI_TIERS if abs(o1)>=th or abs(o5)>=th or abs(o15)>=th)
        cor = (p1*o1>0 and p5*o5>0 and p15*o15>0)
        note = "" if cor else " ⚠️疑是空方進場"
        lines += [
            f"💹 持倉異動 {fires}{note}",
            f" • 1m: {o1:+.2f}% 5m: {o5:+.2f}% 15m: {o15:+.2f}%"
        ]

    lines.append(f"時間：{now}")
    send_alert("\n".join(lines))

# ========== 歷史資料儲存 ==========
history = {}  # {symbol: {'spot': [(timestamp, price, volume)], 'futures': [(timestamp, open_interest)]}}

# ========== 主循環 ==========
# ========== 主循環 ==========
history = {}  # symbol→{'spot':[(ts,val)],'futures':[(ts,val)]}

def main():
    syms = get_binance_futures_symbols_via_requests()
    if not syms:
        logging.error("無合約可監控，程式結束"); return

    # 啟動通知
    init_msg = f"🛰️ Ashdata監控啟動：共偵測到 {len(syms)} 個合約"
    logging.info(init_msg); send_alert(init_msg)

    # init history
    for s in syms:
        history[s] = {'spot':[], 'futures':[]}

    while True:
        t0 = time.time()
        for symbol in syms:
            base = symbol.split('/')[0]
            spot_sym = f"{base}/USDT"

            # pick best spot ex
            best_ex, maxv = None,0
            for ex in exchanges.values():
                if spot_sym not in ex.symbols: continue
                try:
                    qv=ex.fetch_ticker(spot_sym).get('quoteVolume',0)
                    if qv>maxv: best_ex,maxv=ex,qv
                except: pass
            if not best_ex: continue

            # fetch spot 1m price
            try:
                ohlcv=best_ex.fetch_ohlcv(spot_sym,'1m',limit=2)
                prev=ohlcv[-2][4]; curr=ohlcv[-1][4]
            except: continue

            # fetch futures OI
            try:
                curr_oi=float(binance_futures.fetch_open_interest(symbol)['openInterest'])
            except: continue

            now=datetime.utcnow()
            sh=history[symbol]['spot']; fh=history[symbol]['futures']
            sh.append((now,curr)); fh.append((now,curr_oi))

            # clean >15min
            cutoff=now-timedelta(minutes=15)
            history[symbol]['spot']   =[x for x in sh if x[0]>=cutoff]
            history[symbol]['futures']=[x for x in fh if x[0]>=cutoff]

            # format & alert
            format_and_send(symbol, history[symbol]['spot'], history[symbol]['futures'])
            time.sleep(0.2)

        elapsed=time.time()-t0
        if elapsed<60: time.sleep(60-elapsed)

if __name__=='__main__':
    main()
