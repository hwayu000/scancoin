import os
import time
import requests
import json
import math
from datetime import datetime, timedelta
import pytz # ç”¨æ–¼è™•ç†æ™‚å€ï¼Œé€™æ˜¯å€‹å¥½ç¿’æ…£
import re # ç”¨æ–¼æ­£è¦è¡¨é”å¼ï¼Œè™•ç†IPå°é–è¨Šæ¯
import asyncio # ç”¨æ–¼éåŒæ­¥æ“ä½œï¼Œä¾‹å¦‚ç™¼é€Telegramè¨Šæ¯

# --- é…ç½®å€å¡Š ---
# å¾ç’°å¢ƒè®Šæ•¸ä¸­ç²å– Telegram æ©Ÿå™¨äºº Token å’Œ Chat IDã€‚
# å¦‚æœç’°å¢ƒè®Šæ•¸æœªè¨­ç½®ï¼Œå‰‡ä½¿ç”¨é è¨­å€¼ã€‚è«‹å‹™å¿…æ›¿æ›ç‚ºä½ è‡ªå·±çš„å€¼ï¼
# é€™è£¡çš„é è¨­å€¼æ‡‰è©²èˆ‡ä½ åœ¨ /etc/environment ä¸­è¨­ç½®çš„å®Œå…¨ä¸€è‡´
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')

# å¹£å®‰ API ç«¯é» (ä¸ç”¨æ”¹å‹•)
BINANCE_FUTURES_EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo"
BINANCE_FUTURES_OPEN_INTEREST_URL = "https://fapi.binance.com/fapi/v1/openInterest"
BINANCE_SPOT_MINITICKER_URL = "https://api.binance.com/api/v3/ticker/24hr" # ä½¿ç”¨24å°æ™‚è¡Œæƒ…APIç²å–ç¾è²¨åƒ¹æ ¼

# åƒ¹æ ¼è®Šå‹•è©•ç´šé–¾å€¼
PRICE_TIERS = [
    {"threshold": 5.0, "rating": "â­â­â­â­"},
    {"threshold": 4.0, "rating": "â­â­â­"},
    {"threshold": 3.0, "rating": "â­â­"},
    {"threshold": 2.0, "rating": "â­"}
]

# æŒå€‰é‡è®Šå‹•è©•ç´šé–¾å€¼
OI_TIERS = [
    {"threshold": 5.0, "rating": "ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥"},
    {"threshold": 3.5, "rating": "ğŸ”¥ğŸ”¥ğŸ”¥"},
    {"threshold": 3.0, "rating": "ğŸ”¥ğŸ”¥"},
    {"threshold": 2.5, "rating": "ğŸ”¥"}
]

# è­¦å ±å†·å»æ™‚é–“ (åˆ†é˜)ï¼Œé¿å…é »ç¹ç™¼é€ç›¸åŒè­¦å ±
ALERT_COOLDOWN_MINUTES = 5

# æ•¸æ“šå„²å­˜ï¼šæ¯å€‹äº¤æ˜“å°çš„æ­·å²åƒ¹æ ¼ã€æŒå€‰é‡ã€è­¦å ±æ™‚é–“æˆ³ç­‰
# æ ¼å¼: {symbol: {'spot': [{'timestamp': datetimeç‰©ä»¶, 'value': float}], 'futures': [...], 'last_alert_time': datetimeç‰©ä»¶, 'first_alert_time': datetimeç‰©ä»¶, 'subsequent_alert_times': [datetimeç‰©ä»¶]}}
history_data = {}
monitored_symbols = [] # ç›®å‰æ­£åœ¨ç›£æ§çš„äº¤æ˜“å°åˆ—è¡¨ï¼Œä¾‹å¦‚ï¼š'BTC/USDT'

# IP å°é–ç‹€æ…‹è¿½è¹¤ (ç”¨æ–¼å¹£å®‰ API)
is_ip_banned = False
ban_until = None # datetime ç‰©ä»¶ï¼Œè¡¨ç¤ºå°é–è§£é™¤çš„æ™‚é–“

# --- è¼”åŠ©å‡½æ•¸ ---

def calculate_percentage_change(data_array, minutes):
    """
    è¨ˆç®—çµ¦å®šæ•¸æ“šé™£åˆ—åœ¨æŒ‡å®šåˆ†é˜å…§çš„ç™¾åˆ†æ¯”è®Šå‹•ã€‚
    data_array: åŒ…å« {timestamp, value} å­—å…¸çš„åˆ—è¡¨
    minutes: æ™‚é–“ç¯„åœï¼ˆåˆ†é˜ï¼‰
    è¿”å›å€¼: ç™¾åˆ†æ¯”è®Šå‹•ï¼Œå¦‚æœæ•¸æ“šä¸è¶³å‰‡è¿”å› None
    """
    if not data_array:
        return None

    now = datetime.now(pytz.utc) # ç²å–ç•¶å‰ UTC æ™‚é–“
    cutoff_time = now - timedelta(minutes=minutes)

    old_val = None
    # å¾æ•¸æ“šé™£åˆ—çš„æœ«å°¾é–‹å§‹éæ­·ï¼Œæ‰¾åˆ°æœ€æ¥è¿‘æˆ–æ—©æ–¼æˆªæ­¢æ™‚é–“çš„æ•¸æ“šé»
    for item in reversed(data_array):
        if item['timestamp'] <= cutoff_time:
            old_val = item['value']
            break

    new_val = data_array[-1]['value'] if data_array else None

    # å¦‚æœæ²’æœ‰è¶³å¤ çš„æ•¸æ“šï¼Œæˆ–è€…èˆŠå€¼ç‚º 0 (é¿å…é™¤ä»¥é›¶)ï¼Œå‰‡è¿”å› None
    if old_val is None or new_val is None or old_val == 0:
        return None

    return ((new_val - old_val) / old_val) * 100

def get_rating_info(value, tiers):
    """
    æ ¹æ“šå€¼å’Œå®šç¾©çš„è©•ç´šå±¤ç´šç²å–è©•ç´šç¬¦è™Ÿã€‚
    """
    abs_value = abs(value)
    for tier in tiers:
        if abs_value >= tier["threshold"]:
            return tier["rating"]
    return ""

def format_large_number(num):
    """
    å°‡å¤§æ•¸å­—æ ¼å¼åŒ–ç‚ºå¸¶æœ‰ K/M/B å–®ä½å’Œå…©ä½å°æ•¸çš„å­—ä¸²ã€‚
    """
    if num is None or math.isnan(num):
        return 'N/A'
    if num >= 1_000_000_000:
        return f"{(num / 1_000_000_000):.2f}B"
    elif num >= 1_000_000:
        return f"{(num / 1_000_000):.2f}M"
    elif num >= 1_000:
        return f"{(num / 1_000):.2f}K"
    else:
        return f"{num:.2f}"

async def send_telegram_alert(message):
    """
    é€é Telegram Bot ç™¼é€è¨Šæ¯ã€‚
    """
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("éŒ¯èª¤ï¼šTelegram BOT_TOKEN æˆ– CHAT_ID æœªé…ç½®ã€‚ç„¡æ³•ç™¼é€è¨Šæ¯ã€‚")
        return

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': message,
        'parse_mode': 'HTML' # ä½¿ç”¨ HTML æ¨¡å¼ï¼Œä»¥ä¾¿ç™¼é€ç²—é«”ã€æ›è¡Œç­‰æ ¼å¼
    }
    try:
        response = requests.post(url, json=payload, timeout=10) # è¨­ç½®10ç§’è¶…æ™‚
        response.raise_for_status() # å¦‚æœéŸ¿æ‡‰ç‹€æ…‹ç¢¼æ˜¯ 4xx æˆ– 5xxï¼Œå‰‡æ‹‹å‡º HTTPError ç•°å¸¸
        print(f"DEBUG: Telegram è¨Šæ¯ç™¼é€æˆåŠŸ: {message.splitlines()[0]}") # ç°¡åŒ–æ—¥èªŒè¼¸å‡ºï¼ŒåŠ å…¥DEBUG
    except requests.exceptions.HTTPError as e:
        print(f"ERROR: ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: HTTP éŒ¯èª¤ {e.response.status_code} - {e.response.text}")
    except requests.exceptions.RequestException as e:
        print(f"ERROR: ç™¼é€ Telegram è¨Šæ¯å¤±æ•—: ç¶²è·¯éŒ¯èª¤ - {e}")
    except Exception as e: # æ•æ‰å…¶ä»–ä»»ä½•å¯èƒ½çš„éŒ¯èª¤
        print(f"ERROR: ç™¼é€ Telegram è¨Šæ¯æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")


def retry_fetch(url, retries=3, delay=1):
    """
    å¸¶æœ‰é‡è©¦é‚è¼¯çš„ fetch è«‹æ±‚ï¼Œä¸¦è™•ç†å¹£å®‰çš„ IP å°é–ã€‚
    """
    global is_ip_banned, ban_until # è²æ˜ç‚ºå…¨åŸŸè®Šæ•¸ä»¥ä¾¿ä¿®æ”¹
    for i in range(retries):
        try:
            response = requests.get(url, timeout=10) # 10ç§’è¶…æ™‚
            response.raise_for_status() # æª¢æŸ¥ HTTP ç‹€æ…‹ç¢¼
            is_ip_banned = False # å¦‚æœæˆåŠŸï¼Œæ¸…é™¤å°é–ç‹€æ…‹
            ban_until = None
            return response.json()
        except requests.exceptions.HTTPError as e:
            error_text = e.response.text
            print(f"WARNING: ç¬¬ {i + 1} æ¬¡ç²å–å¤±æ•—: {url}ï¼Œç‹€æ…‹ç¢¼ {e.response.status_code}: {error_text}")

            # æª¢æŸ¥æ˜¯å¦ç‚º IP å°é–éŒ¯èª¤ (HTTP 418, 429 æˆ–å¹£å®‰ç‰¹å®šçš„éŒ¯èª¤ç¢¼ -1003)
            if e.response.status_code in [418, 429] or ("-1003" in error_text and "banned" in error_text):
                is_ip_banned = True
                ban_match = re.search(r"banned until (\d+)", error_text) # å˜—è©¦è§£æå°é–è§£é™¤æ™‚é–“æˆ³
                if ban_match:
                    ban_timestamp_ms = int(ban_match.group(1))
                    ban_until = datetime.fromtimestamp(ban_timestamp_ms / 1000, tz=pytz.utc) # è½‰æ›ç‚º datetime ç‰©ä»¶
                    print(f"CRITICAL: IP å·²è¢«å¹£å®‰å°é–ï¼Œç›´åˆ°: {ban_until.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                else:
                    ban_until = datetime.now(pytz.utc) + timedelta(minutes=5) # å¦‚æœæ²’æœ‰å…·é«”æ™‚é–“ï¼Œå‡è¨­å°é– 5 åˆ†é˜
                    print("CRITICAL: IP å·²è¢«å¹£å®‰å°é– (æœªæä¾›å…·é«”æ™‚é–“)ï¼Œå‡å®šå°é– 5 åˆ†é˜ã€‚")

                raise Exception(f"IP è¢«å°é–: {error_text}") # æ‹‹å‡ºç•°å¸¸ï¼Œè®“ä¸Šå±¤é‚è¼¯è™•ç†ç­‰å¾…
            else:
                if i < retries - 1:
                    wait_time = delay * (2 ** i) # æŒ‡æ•¸é€€é¿ï¼Œç­‰å¾…æ™‚é–“åŠ å€
                    print(f"INFO: å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                    time.sleep(wait_time)
                else:
                    raise e # æœ€å¾Œä¸€æ¬¡å˜—è©¦å¤±æ•—ï¼Œæ‹‹å‡ºåŸå§‹éŒ¯èª¤
        except requests.exceptions.RequestException as e:
            print(f"ERROR: ç¬¬ {i + 1} æ¬¡ç²å–ç¶²è·¯éŒ¯èª¤: {url}: {e}")
            if i < retries - 1:
                wait_time = delay * (2 ** i)
                print(f"INFO: å°‡åœ¨ {wait_time} ç§’å¾Œé‡è©¦...")
                time.sleep(wait_time)
            else:
                raise e # æœ€å¾Œä¸€æ¬¡å˜—è©¦å¤±æ•—ï¼Œæ‹‹å‡ºåŸå§‹éŒ¯èª¤

    raise Exception(f"CRITICAL: åœ¨ {retries} æ¬¡é‡è©¦å¾Œï¼Œä»ç„¡æ³•ç²å– {url}ã€‚")

# --- æ•¸æ“šç²å–å’Œè™•ç† ---

def initialize_monitoring_symbols():
    """
    å‹•æ…‹ç²å–ä¸¦è¨­å®šè¦ç›£æ§çš„äº¤æ˜“å°åˆ—è¡¨ã€‚
    """
    global monitored_symbols, history_data, is_ip_banned, ban_until # è²æ˜ç‚ºå…¨åŸŸè®Šæ•¸

    print("INFO: æ­£åœ¨ç²å–å¯ç›£æ§çš„æœŸè²¨äº¤æ˜“å°åˆ—è¡¨...")
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
        print(f"WARNING: IP ä»ç„¶è¢«å°é–ï¼Œå‰©é¤˜ {remaining_time:.0f} ç§’ã€‚è·³éäº¤æ˜“å°åˆå§‹åŒ–ã€‚")
        return False # è¿”å› False è¡¨ç¤ºåˆå§‹åŒ–å¤±æ•—

    is_ip_banned = False # åœ¨å˜—è©¦ç²å–ä¹‹å‰é‡ç½® IP å°é–ç‹€æ…‹

    try:
        response_data = retry_fetch(BINANCE_FUTURES_EXCHANGE_INFO_URL)
        # éæ¿¾å‡º USDT æœ¬ä½ã€æ°¸çºŒåˆç´„ä¸”ç‹€æ…‹ç‚º 'TRADING' çš„äº¤æ˜“å°
        valid_symbols = [
            s['symbol'].replace('USDT', '/USDT')
            for s in response_data['symbols']
            if s['quoteAsset'] == 'USDT' and s['contractType'] == 'PERPETUAL' and s['status'] == 'TRADING'
        ]

        monitored_symbols = valid_symbols

        # é‡æ–°åˆå§‹åŒ– history_dataï¼Œä¿ç•™å·²å­˜åœ¨çš„æ•¸æ“šï¼Œç‚ºæ–°åŠ å…¥çš„äº¤æ˜“å°å»ºç«‹ç©ºæ­·å²æ•¸æ“š
        new_history_data = {}
        for symbol in monitored_symbols:
            if symbol in history_data:
                new_history_data[symbol] = history_data[symbol] # ä¿ç•™èˆŠæ•¸æ“š
            else:
                new_history_data[symbol] = {
                    'spot': [],
                    'futures': [],
                    'last_alert_time': None,
                    'first_alert_time': None,
                    'subsequent_alert_times': []
                }
        history_data = new_history_data # æ›´æ–°å…¨åŸŸè®Šæ•¸

        print(f"INFO: å·²è¼‰å…¥ {len(monitored_symbols)} å€‹æœŸè²¨äº¤æ˜“å°: {monitored_symbols[:5]}...") # åªé¡¯ç¤ºå‰5å€‹ä»¥ç¯€çœæ—¥èªŒç©ºé–“
        if not monitored_symbols:
            print("WARNING: æ²’æœ‰æ‰¾åˆ°å¯ç›£æ§çš„äº¤æ˜“å°ã€‚")
            return False
        return True # è¿”å› True è¡¨ç¤ºåˆå§‹åŒ–æˆåŠŸ

    except Exception as e:
        print(f"ERROR: ç²å–æœŸè²¨äº¤æ˜“å°åˆ—è¡¨å¤±æ•—: {e}")
        return False

def fetch_spot_prices():
    """
    ç²å–æ‰€æœ‰ç›£æ§äº¤æ˜“å°çš„ç•¶å‰ç¾è²¨åƒ¹æ ¼ã€‚
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    # print("INFO: æ­£åœ¨ç²å–ç¾è²¨åƒ¹æ ¼...") # é¿å…éå¤šæ—¥èªŒ
    try:
        # ç²å–æ‰€æœ‰ 24 å°æ™‚è¡Œæƒ…æ•¸æ“šï¼Œç„¶å¾Œé€²è¡Œç¯©é¸
        all_tickers = retry_fetch(BINANCE_SPOT_MINITICKER_URL)
        now = datetime.now(pytz.utc)

        for ticker in all_tickers:
            symbol_raw = ticker['symbol']
            formatted_symbol = symbol_raw.replace('USDT', '/USDT')
            price = float(ticker['lastPrice'])

            if formatted_symbol in monitored_symbols:
                # ç¢ºä¿ history_data ä¸­æœ‰è©²äº¤æ˜“å°çš„æ¢ç›®
                if formatted_symbol not in history_data:
                    history_data[formatted_symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
                history_data[formatted_symbol]['spot'].append({'timestamp': now, 'value': price})

                # æ¸…ç†èˆŠæ•¸æ“šï¼Œåªä¿ç•™æœ€è¿‘ 16 åˆ†é˜çš„æ•¸æ“šï¼ˆå¤šä¿ç•™ä¸€é»ç¢ºä¿è¨ˆç®—æº–ç¢ºï¼‰
                cutoff = now - timedelta(minutes=16)
                while len(history_data[formatted_symbol]['spot']) > 0 and history_data[formatted_symbol]['spot'][0]['timestamp'] < cutoff:
                    history_data[formatted_symbol]['spot'].pop(0)

    except Exception as e:
        print(f"ERROR: ç²å–ç¾è²¨åƒ¹æ ¼å¤±æ•—: {e}")


def fetch_open_interest_rest():
    """
    ç²å–æ¯å€‹ç›£æ§äº¤æ˜“å°çš„æœŸè²¨æŒå€‰é‡æ•¸æ“šã€‚
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    # print("INFO: æ­£åœ¨ç²å–æœŸè²¨æŒå€‰é‡...") # é¿å…éå¤šæ—¥èªŒ
    delay_between_requests = 0.5 # æ¯å€‹è«‹æ±‚ä¹‹é–“é–“éš” 0.5 ç§’

    # éæ­·ç›£æ§çš„äº¤æ˜“å°åˆ—è¡¨çš„å‰¯æœ¬ï¼Œå› ç‚ºåˆ—è¡¨ä¸­å¯èƒ½æœƒæœ‰å…ƒç´ è¢«ç§»é™¤
    for symbol in list(monitored_symbols):
        binance_symbol = symbol.replace('/', '') # è½‰æ›æˆå¹£å®‰ API éœ€è¦çš„æ ¼å¼ (ä¾‹å¦‚ BTCUSDT)
        url = f"{BINANCE_FUTURES_OPEN_INTEREST_URL}?symbol={binance_symbol}"
        try:
            data = retry_fetch(url)
            open_interest = float(data['openInterest'])
            now = datetime.now(pytz.utc)

            # ç¢ºä¿ history_data ä¸­æœ‰è©²äº¤æ˜“å°çš„æ¢ç›®
            if symbol not in history_data:
                history_data[symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
            history_data[symbol]['futures'].append({'timestamp': now, 'value': open_interest})

            # æ¸…ç†èˆŠæ•¸æ“šï¼Œåªä¿ç•™æœ€è¿‘ 16 åˆ†é˜çš„æ•¸æ“š
            cutoff = now - timedelta(minutes=16)
            while len(history_data[symbol]['futures']) > 0 and history_data[symbol]['futures'][0]['timestamp'] < cutoff:
                history_data[symbol]['futures'].pop(0)

        except Exception as e:
            print(f"ERROR: ç²å– {symbol} æŒå€‰é‡å¤±æ•—: {e}")
            if "IP BANNED" in str(e):
                return # å¦‚æœ IP è¢«å°é–ï¼Œåœæ­¢ç•¶å‰å¾ªç’°
            if "-4108" in str(e) and "Symbol is on delivering" in str(e):
                print(f"WARNING: äº¤æ˜“å° {symbol} ç‹€æ…‹ç„¡æ•ˆ ('Symbol is on delivering')ï¼Œå°‡å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ã€‚")
                monitored_symbols.remove(symbol) # å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤è©²äº¤æ˜“å°
                if symbol in history_data:
                    del history_data[symbol] # ä¹Ÿå¾æ­·å²æ•¸æ“šä¸­ç§»é™¤
        finally:
            # åœ¨æ¯å€‹è«‹æ±‚ä¹‹é–“æ·»åŠ ä¸€å€‹å°å»¶é²ï¼Œé¿å…è§¸ç™¼é€Ÿç‡é™åˆ¶
            time.sleep(delay_between_requests)

def check_and_send_alerts():
    """
    æª¢æŸ¥æ˜¯å¦æœ‰é¡¯è‘—çš„åƒ¹æ ¼/æŒå€‰é‡è®Šå‹•ï¼Œä¸¦ç™¼é€ Telegram è­¦å ±ã€‚
    """
    global history_data
    now = datetime.now(pytz.utc)

    # éæ­·ç›£æ§çš„äº¤æ˜“å°åˆ—è¡¨çš„å‰¯æœ¬ï¼Œå› ç‚ºåˆ—è¡¨ä¸­å¯èƒ½æœƒæœ‰å…ƒç´ è¢«ç§»é™¤
    for symbol in list(monitored_symbols):
        if symbol not in history_data:
            continue

        spot_hist = history_data[symbol]['spot']
        fut_hist = history_data[symbol]['futures']

        # è¨ˆç®—ç™¾åˆ†æ¯”è®Šå‹•
        p1 = calculate_percentage_change(spot_hist, 1)
        p5 = calculate_percentage_change(spot_hist, 5)
        p15 = calculate_percentage_change(spot_hist, 15)

        o1 = calculate_percentage_change(fut_hist, 1)
        o5 = calculate_percentage_change(fut_hist, 5)
        o15 = calculate_percentage_change(fut_hist, 15)

        # ç²å–è©•ç´šè³‡è¨Š (å¦‚æœç‚º None å‰‡å‚³å…¥ 0ï¼Œä»¥ç¢ºä¿ max å‡½æ•¸æ­£å¸¸å·¥ä½œ)
        price_rating = get_rating_info(max(abs(p1) if p1 is not None else 0, abs(p5) if p5 is not None else 0, abs(p15) if p15 is not None else 0), PRICE_TIERS)
        oi_rating = get_rating_info(max(abs(o1) if o1 is not None else 0, abs(o5) if o5 is not None else 0, abs(o15) if o15 is not None else 0), OI_TIERS)

        # åˆ¤æ–·æ˜¯å¦é”åˆ°è­¦å ±é–¾å€¼ (ä½¿ç”¨æœ€ä½é–¾å€¼ä½œç‚ºè§¸ç™¼æ¢ä»¶)
        price_alert_threshold_met = (
            (p1 is not None and abs(p1) >= PRICE_TIERS[-1]["threshold"]) or
            (p5 is not None and abs(p5) >= PRICE_TIERS[-1]["threshold"]) or
            (p15 is not None and abs(p15) >= PRICE_TIERS[-1]["threshold"])
        )

        oi_alert_threshold_met = (
            (o1 is not None and abs(o1) >= OI_TIERS[-1]["threshold"]) or
            (o5 is not None and abs(o5) >= OI_TIERS[-1]["threshold"]) or
            (o15 is not None and abs(o15) >= OI_TIERS[-1]["threshold"])
        )

        # æª¢æŸ¥å†·å»æ™‚é–“ï¼Œé¿å…é »ç¹è­¦å ±
        last_alert_time = history_data[symbol]['last_alert_time']
        if last_alert_time and (now - last_alert_time).total_seconds() / 60 < ALERT_COOLDOWN_MINUTES:
            # print(f"INFO: ç¬¦è™Ÿ {symbol} ä»åœ¨å†·å»ä¸­ï¼Œè·³éè­¦å ±ã€‚") # é¿å…éå¤šæ—¥èªŒ
            continue # ä»åœ¨å†·å»æœŸï¼Œè·³éæ­¤äº¤æ˜“å°çš„è­¦å ±

        alert_message_parts = []
        is_alert_triggered = False

        # è™•ç†åƒ¹æ ¼è­¦å ±
        if price_alert_threshold_met:
            price_alert_message = (
                f"ğŸ“ˆ <b>åƒ¹æ ¼ç•°å‹• {price_rating}è©•ç´š - #{symbol}:</b>\n" # åœ¨å¹£ç¨®å‰åŠ  #
                f"â€¢ 1m: {p1:.2f}% | 5m: {p5:.2f}% | 15m: {p15:.2f}%"
            )
            alert_message_parts.append(price_alert_message)
            is_alert_triggered = True

        # è™•ç†æŒå€‰é‡è­¦å ±
        if oi_alert_threshold_met:
            # åˆ¤æ–·æ˜¯å¦æœ‰åå‘é—œè¯ï¼Œå³åƒ¹æ ¼ä¸‹è·Œè€ŒæŒå€‰é‡å¢åŠ  (ç–‘æ˜¯ç©ºæ–¹é€²å ´)
            note = ""
            # åˆ¤æ–·æ¨™æº–ï¼šå¦‚æœåƒ¹æ ¼è®ŠåŒ–ç‚ºè² ï¼ˆä¸‹è·Œï¼‰ï¼Œä¸”æŒå€‰é‡è®ŠåŒ–ç‚ºæ­£ï¼ˆå¢åŠ ï¼‰ï¼Œå‰‡æç¤ºã€Œç–‘æ˜¯ç©ºæ–¹é€²å ´ã€
            # æˆ‘å€‘æœƒæª¢æŸ¥1m, 5m, 15mä¸­è‡³å°‘ä¸€å€‹ç¬¦åˆæ­¤æ¢ä»¶
            has_bearish_oi_increase = False
            if p1 is not None and o1 is not None and p1 < 0 and o1 > 0:
                has_bearish_oi_increase = True
            if p5 is not None and o5 is not None and p5 < 0 and o5 > 0:
                has_bearish_oi_increase = True
            if p15 is not None and o15 is not None and p15 < 0 and o15 > 0:
                has_bearish_oi_increase = True

            if has_bearish_oi_increase:
                note = " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"

            oi_alert_message = (
                f"ğŸ’¹ <b>æŒå€‰ç•°å‹• {oi_rating}{note} - #{symbol}:</b>\n" # åœ¨å¹£ç¨®å‰åŠ  #
                f"â€¢ 1m: {o1:.2f}% | 5m: {o5:.2f}% | 15m: {o15:.2f}%"
            )
            alert_message_parts.append(oi_alert_message)
            is_alert_triggered = True

        # å¦‚æœæœ‰è­¦å ±è¢«è§¸ç™¼ï¼Œå‰‡ç™¼é€åˆä½µå¾Œçš„è­¦å ±è¨Šæ¯
        if is_alert_triggered:
            # æ›´æ–°è­¦å ±æ™‚é–“æˆ³
            if history_data[symbol]['first_alert_time'] is None:
                history_data[symbol]['first_alert_time'] = now
                history_data[symbol]['subsequent_alert_times'] = []
            else:
                history_data[symbol]['subsequent_alert_times'].append(now)

            # çµ„åˆè¨Šæ¯çš„æœ€å¾Œä¸€è¡Œï¼ŒåŒ…å«é¦–æ¬¡è§¸ç™¼å’Œä¸Šæ¬¡è§¸ç™¼æ™‚é–“
            timestamp_info = ""
            first_alert_str = history_data[symbol]['first_alert_time'].strftime("%Y-%m-%d %H:%M:%S")
            timestamp_info += f"\né¦–æ¬¡è§¸ç™¼æ™‚é–“: {first_alert_str} (UTC)"

            if history_data[symbol]['subsequent_alert_times']:
                # å–å¾—æœ€è¿‘ä¸€æ¬¡çš„å¾ŒçºŒè§¸ç™¼æ™‚é–“
                last_subsequent_str = history_data[symbol]['subsequent_alert_times'][-1].strftime("%Y-%m-%d %H:%M:%S")
                timestamp_info += f"\nä¸Šæ¬¡è§¸ç™¼æ™‚é–“: {last_subsequent_str} (UTC)"

            final_alert_message = "\n\n".join(alert_message_parts) + timestamp_info

            # ç™¼é€ Telegram è­¦å ±
            asyncio.run(send_telegram_alert(final_alert_message))
            history_data[symbol]['last_alert_time'] = now # æ›´æ–°å†·å»è¨ˆæ™‚å™¨

# --- ä¸»æ‡‰ç”¨ç¨‹å¼å¾ªç’° ---

async def main_loop():
    """
    ä¸»è¦å¾ªç’°ï¼Œè² è²¬ç²å–æ•¸æ“šå’Œæª¢æŸ¥è­¦å ±ã€‚
    """
    global is_ip_banned, ban_until

    # --- ç¨‹å¼å•Ÿå‹•ç¢ºèªè¨Šæ¯ ---
    start_message = "Ashdataæƒéˆç¨‹å¼å·²å•Ÿå‹•ï¼æ­£åœ¨åˆå§‹åŒ–äº¤æ˜“å°åˆ—è¡¨..."
    print(f"DEBUG: å˜—è©¦ç™¼é€å•Ÿå‹•è¨Šæ¯: {start_message}") # æ–°å¢æ—¥èªŒ
    try:
        await send_telegram_alert(start_message)
        print("DEBUG: å•Ÿå‹•è¨Šæ¯ç™¼é€æˆåŠŸã€‚") # æ–°å¢æ—¥èªŒ
    except Exception as e:
        print(f"ERROR: å•Ÿå‹•è¨Šæ¯ç™¼é€å¤±æ•—: {e}") # æ–°å¢éŒ¯èª¤æ—¥èªŒ

    # é¦–æ¬¡å˜—è©¦åˆå§‹åŒ–äº¤æ˜“å°ã€‚å¦‚æœå¤±æ•—ï¼Œå‰‡ç­‰å¾…ä¸¦é‡è©¦ã€‚
    init_success = False
    while not init_success:
        init_success = initialize_monitoring_symbols()
        if not init_success:
            print("WARNING: åˆå§‹åŒ–äº¤æ˜“å°å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
            try: # å˜—è©¦ç™¼é€éŒ¯èª¤è¨Šæ¯åˆ° Telegram
                await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚è«‹æª¢æŸ¥ä¼ºæœå™¨æ—¥èªŒã€‚")
            except:
                pass # é¿å…å†æ¬¡å¤±æ•—å°è‡´å¾ªç’°
            await asyncio.sleep(60)

    # åˆå§‹åŒ–æˆåŠŸå¾Œï¼Œå†æ¬¡ç™¼é€è¨Šæ¯ï¼ŒåŒ…å«åµæ¸¬åˆ°çš„æ¨™çš„æ•¸é‡
    startup_complete_message = f"Ashdataæƒéˆå·²åµæ¸¬åˆ° <b>{len(monitored_symbols)}</b> ç¨®æ¨™çš„ã€‚ç›£æ§æœå‹™æ­£å¼å•Ÿå‹•ï¼"
    print(f"DEBUG: å˜—è©¦ç™¼é€å•Ÿå‹•å®Œæˆè¨Šæ¯: {startup_complete_message}") # æ–°å¢æ—¥èªŒ
    try:
        await send_telegram_alert(startup_complete_message)
        print("DEBUG: å•Ÿå‹•å®Œæˆè¨Šæ¯ç™¼é€æˆåŠŸã€‚") # æ–°å¢æ—¥èªŒ
    except Exception as e:
        print(f"ERROR: å•Ÿå‹•å®Œæˆè¨Šæ¯ç™¼é€å¤±æ•—: {e}") # æ–°å¢éŒ¯èª¤æ—¥èªŒ

    while True:
        if is_ip_banned:
            if ban_until and datetime.now(pytz.utc) < ban_until:
                # å¦‚æœé‚„åœ¨å°é–æœŸå…§ï¼Œè¨ˆç®—å‰©é¤˜æ™‚é–“ä¸¦ç­‰å¾…
                remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
                print(f"WARNING: IP ä»ç„¶è¢«å°é–ã€‚å°‡ç­‰å¾… {remaining_time:.0f} ç§’å¾Œé‡è©¦æ‰€æœ‰æ•¸æ“šç²å–ã€‚")
                try: # å˜—è©¦ç™¼é€ IP å°é–è¨Šæ¯åˆ° Telegram
                    await send_telegram_alert(f"âš ï¸ è­¦å ±ï¼šAshdataæƒéˆIPå·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œå‰©é¤˜ç´„ {remaining_time:.0f} ç§’ã€‚")
                except:
                    pass
                await asyncio.sleep(max(10, remaining_time + 5)) # ä½¿ç”¨ asyncio.sleep
                continue # è·³éæœ¬æ¬¡æ•¸æ“šç²å–å¾ªç’°
            else:
                # å¦‚æœ IP å°é–å¯èƒ½å·²è§£é™¤ï¼Œå˜—è©¦æ¸…é™¤å°é–ç‹€æ…‹ä¸¦é‡æ–°åˆå§‹åŒ–
                print("INFO: IP å°é–å¯èƒ½å·²è§£é™¤ã€‚æ­£åœ¨å˜—è©¦æ¸…é™¤å°é–ç‹€æ…‹ä¸¦é‡æ–°åˆå§‹åŒ–ã€‚")
                is_ip_banned = False
                ban_until = None
                # é‡æ–°åˆå§‹åŒ–äº¤æ˜“å°ï¼Œç¢ºä¿ç²å–åˆ°æœ€æ–°çš„åˆ—è¡¨ä¸¦é‡ç½®é€£æ¥
                init_success = initialize_monitoring_symbols()
                if not init_success:
                    print("WARNING: è§£é™¤å°é–å¾Œçš„é‡æ–°åˆå§‹åŒ–å¤±æ•—ã€‚å°‡åœ¨ 60 ç§’å¾Œé‡è©¦...")
                    try: # å˜—è©¦ç™¼é€éŒ¯èª¤è¨Šæ¯åˆ° Telegram
                        await send_telegram_alert("âš ï¸ éŒ¯èª¤ï¼šAshdataæƒéˆè§£é™¤IPå°é–å¾Œåˆå§‹åŒ–å¤±æ•—ï¼Œæ­£åœ¨é‡è©¦ã€‚")
                    except:
                        pass
                    await asyncio.sleep(60)
                    continue

        # ç²å–ç¾è²¨åƒ¹æ ¼å’ŒæŒå€‰é‡
        print("INFO: é–‹å§‹ç²å–ç¾è²¨åƒ¹æ ¼å’ŒæœŸè²¨æŒå€‰é‡...")
        fetch_spot_prices()
        fetch_open_interest_rest() # é€™å€‹å‡½æ•¸å…§éƒ¨æœƒè™•ç†æ¯å€‹äº¤æ˜“å°ä¹‹é–“çš„å»¶é²
        print("INFO: å®Œæˆæ•¸æ“šç²å–ã€‚")

        # æª¢æŸ¥ä¸¦ç™¼é€è­¦å ±
        print("INFO: æª¢æŸ¥ä¸¦ç™¼é€è­¦å ±...")
        check_and_send_alerts()
        print("INFO: è­¦å ±æª¢æŸ¥å®Œæˆã€‚")

        # æ ¹æ“šç›£æ§çš„äº¤æ˜“å°æ•¸é‡è¨ˆç®—ä¸‹ä¸€æ¬¡ç²å–æ•¸æ“šçš„é–“éš”æ™‚é–“
        min_fetch_interval = 60 # ç§’
        calculated_fetch_interval = len(monitored_symbols) * 0.5 + 10 # ä¼°è¨ˆç²å–æ™‚é–“ + ç·©è¡
        next_interval = max(min_fetch_interval, calculated_fetch_interval)

        print(f"INFO: ä¸‹ä¸€æ¬¡æ•¸æ“šç²å–å’Œè­¦å ±æª¢æŸ¥å°‡åœ¨ {next_interval:.0f} ç§’å¾Œé€²è¡Œ...") # é¿å…éå¤šæ—¥èªŒ
        await asyncio.sleep(next_interval) # ä½¿ç”¨ asyncio.sleep é€²è¡ŒéåŒæ­¥ç­‰å¾…

if __name__ == "__main__":
    asyncio.run(main_loop())
