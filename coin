import os
import sys
import time
import logging
import requests
import json # ç”¨æ–¼è§£æ Binance éŒ¯èª¤è¨Šæ¯
from datetime import datetime, timedelta
from dotenv import load_dotenv
from collections import deque
import ccxt

# ========== è¨­å®š logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
load_dotenv() # å¾ .env æ–‡ä»¶è¼‰å…¥ç’°å¢ƒè®Šæ•¸

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')

# ç¢ºèª Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN æˆ– TELEGRAM_CHAT_ID æœªè¨­å®šï¼è«‹æª¢æŸ¥ .env æª”æˆ–ç›´æ¥åœ¨ç¨‹å¼ç¢¼ä¸­è¨­å®šã€‚")
    sys.exit(1)

# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ ==========
# é€™è£¡æˆ‘å€‘ä¸»è¦ä½¿ç”¨ Binanceï¼Œå› ç‚ºå…¶æœŸè²¨ OI éœ€é€é REST API ç²å–
# ç¢ºä¿ ccxt å·²å®‰è£
try:
    import ccxt
except ImportError:
    logging.info("ccxt æœªæ‰¾åˆ°ï¼Œæ­£åœ¨å®‰è£ ccxt...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt

binance_futures = ccxt.binance({
    'enableRateLimit': True, # å•Ÿç”¨ ccxt å…§å»ºçš„é€Ÿç‡é™åˆ¶
    'options': {'defaultType': 'future'}
})
binance_spot = ccxt.binance({
    'enableRateLimit': True,
    'options': {'defaultType': 'spot'}
})

# è¼‰å…¥æ‰€æœ‰ marketsï¼Œä¿è­‰ .markets å¯ç”¨
try:
    binance_futures.load_markets()
    binance_spot.load_markets()
    logging.info("å¹£å®‰æœŸè²¨å’Œç¾è²¨å¸‚å ´è¼‰å…¥æˆåŠŸã€‚")
except Exception as e:
    logging.error(f"CCXT è¼‰å…¥å¸‚å ´å¤±æ•—: {e}")
    sys.exit(1)

# ========== é–¾å€¼è¨­å®š ==========
PRICE_TIERS = [(5.0,'â­â­â­â­'),(4.0,'â­â­â­'),(3.0,'â­â­'),(2.0,'â­')]
OI_TIERS    = [(5.0,'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥'),(3.5,'ğŸ”¥ğŸ”¥ğŸ”¥'),(3.0,'ğŸ”¥ğŸ”¥'),(2.5,'ğŸ”¥')]

# IP å°é–ç‹€æ…‹è¿½è¹¤
is_ip_banned = False
ban_until = 0 # å°é–è§£é™¤æ™‚é–“æˆ³ (æ¯«ç§’)

# ========== å…¨åŸŸè³‡æ–™å„²å­˜ ==========
# {symbol: {'spot': deque(), 'futures': deque(), 'last_alert_time': datetime, 'latest_price_changes': {}, 'latest_oi_changes': {}}}
history = {}

# ========== è¼”åŠ©å‡½æ•¸ï¼šç²å–è©•ç´šç¬¦è™Ÿ ==========
def get_rating_symbols(value, tiers):
    abs_value = abs(value)
    for threshold, rating in tiers:
        if abs_value >= threshold:
            return rating
    return ''

# ========== ç™¼é€ Telegram è­¦å ± ==========
def send_alert(message: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message, 'parse_mode': 'HTML'}
    try:
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            logging.warning(f"Telegram ç™¼é€å¤±æ•—: {r.status_code} - {r.text}")
            try:
                logging.warning(f"Telegram API å›æ‡‰è©³æƒ…: {r.json()}")
            except json.JSONDecodeError:
                logging.warning("Telegram API å›æ‡‰é JSON æ ¼å¼ã€‚")
        else:
            logging.info("Telegram è¨Šæ¯ç™¼é€æˆåŠŸï¼")
    except Exception as e:
        logging.error(f"Telegram ç™¼é€ç•°å¸¸: {e}")

# ========== æ ¼å¼åŒ–ä¸¦ç™¼é€å ±æ–‡ ==========
def format_and_send(symbol, spot_hist, fut_hist, timeframe='1m'):
    # è¨ˆç®—ç™¾åˆ†æ¯”è®Šå‹•
    def pct(arr, mins):
        cutoff = datetime.utcnow() - timedelta(minutes=mins)
        # å¾å¾Œå¾€å‰æ‰¾ï¼Œæ‰¾åˆ°æœ€æ¥è¿‘æˆ–æ—©æ–¼æˆªæ­¢æ™‚é–“çš„è³‡æ–™é»
        old_val_entry = next(((t, v) for t, v in reversed(arr) if t <= cutoff), None)
        new_val_entry = arr[-1] if arr else None

        if old_val_entry is None or new_val_entry is None:
            return None # è³‡æ–™ä¸è¶³å‰‡è¿”å› None

        old_val = old_val_entry[1]
        new_val = new_val_entry[1]

        return ((new_val - old_val) / old_val * 100) if (old_val != 0) else 0.0

    p1, p5, p15 = pct(spot_hist, 1), pct(spot_hist, 5), pct(spot_hist, 15)
    o1, o5, o15 = pct(fut_hist, 1), pct(fut_hist, 5), pct(fut_hist, 15)

    # åˆ¤æ–·æ˜¯å¦æœ‰è¶³å¤ çš„æ•¸æ“šä¾†è¨ˆç®—è®ŠåŒ–é‡
    has_price_changes = all(v is not None for v in [p1, p5, p15])
    has_oi_changes = all(v is not None for v in [o1, o5, o15])

    price_alert = False
    if has_price_changes:
        price_alert = max(abs(p1), abs(p5), abs(p15)) >= PRICE_TIERS[-1][0]
    
    oi_alert = False
    if has_oi_changes:
        oi_alert = max(abs(o1), abs(o5), abs(o15)) >= OI_TIERS[-1][0]
    
    if not price_alert and not oi_alert:
        return

    # å¯¦æ–½è­¦å ±å†·å»æ™‚é–“ï¼Œé¿å…é‡è¤‡ç™¼é€
    now = datetime.utcnow()
    last_alert_time = history[symbol].get('last_alert_time')
    if last_alert_time and (now - last_alert_time) < timedelta(minutes=1): # 1 åˆ†é˜å†·å»æ™‚é–“
        logging.debug(f"{symbol} çš„è­¦å ±è™•æ–¼å†·å»æœŸã€‚")
        return

    # 1ï¸âƒ£ ç¬¬ä¸€æ®µï¼šæ¨™é¡Œ
    header = ""
    if price_alert:
        stars = get_rating_symbols(max(abs(p) for p in [p1, p5, p15] if p is not None), PRICE_TIERS)
        header = f"ğŸ“ˆ åƒ¹æ ¼ç•°å‹• {stars}è©•ç´š"
    
    if oi_alert: # å¦‚æœåŒæ™‚æœ‰åƒ¹æ ¼å’Œ OI ç•°å‹•ï¼Œå‰‡åˆä½µæ¨™é¡Œ
        fires = get_rating_symbols(max(abs(o) for o in [o1, o5, o15] if o is not None), OI_TIERS)
        cor = (p1 is not None and o1 is not None and p1 * o1 > 0 and 
               p5 is not None and o5 is not None and p5 * o5 > 0 and 
               p15 is not None and o15 is not None and p15 * o15 > 0) # æª¢æŸ¥åƒ¹æ ¼å’ŒæŒå€‰é‡æ˜¯å¦åŒå‘è®Šå‹•
        note = "" if cor else " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"
        
        if header: # å¦‚æœå·²ç¶“æœ‰åƒ¹æ ¼æ¨™é¡Œ
            header += f" | ğŸ’¹ æŒå€‰ç•°å‹• {fires}{note}"
        else:
            header = f"ğŸ’¹ æŒå€‰ç•°å‹• {fires}{note}"

    # 2ï¸âƒ£ ç¬¬äºŒæ®µï¼šäº¤æ˜“å°
    pair_line = f"{symbol.replace('/', '')}"

    # 3ï¸âƒ£ ç¬¬ä¸‰æ®µï¼šTimeframe
    tf_line = f"Timeframe: {timeframe}"

    # ç´°ç¯€è¡Œ
    lines = [header, pair_line, tf_line]
    if price_alert:
        lines.append(f" â€¢ ç¾è²¨ 1m: {p1:+.2f}% | 5m: {p5:+.2f}% | 15m: {p15:+.2f}%")
    if oi_alert:
        lines.append(f" â€¢ æŒå€‰ 1m: {o1:+.2f}% | 5m: {o5:+.2f}% | 15m: {o15:+.2f}%")

    lines.append(f"æ™‚é–“ï¼š{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC")
    send_alert("\n".join(lines))
    history[symbol]['last_alert_time'] = now # æ›´æ–°æœ€å¾Œè­¦å ±æ™‚é–“

# ========== å–å¾— Binance æœŸè²¨ USDT æ°¸çºŒåˆç´„åˆ—è¡¨ ==========
def get_binance_futures_symbols_via_requests():
    global is_ip_banned, ban_until
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        # ä½¿ç”¨ requests ç²å–ï¼Œä¸¦è™•ç†æ½›åœ¨çš„ IP å°é–
        response = requests.get(url, timeout=10)
        response.raise_for_status() # å°æ–¼ 4xx/5xx éŒ¯èª¤æ‹‹å‡º HTTPError

        data = response.json()
        
        # æª¢æŸ¥æ˜¯å¦ç‚º IP å°é–éŒ¯èª¤ç¢¼
        if response.status_code == 418 or (data.get('code') == -1003 and 'banned' in data.get('msg', '')):
            is_ip_banned = True
            ban_match = data.get('msg', '').split('banned until ')
            if len(ban_match) > 1:
                ban_until = int(ban_match[1].split('.')[0]) # è§£ææ™‚é–“æˆ³
                logging.error(f"IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œç›´åˆ° {datetime.fromtimestamp(ban_until / 1000).strftime('%Y-%m-%d %H:%M:%S')}ã€‚")
            else:
                logging.error(f"IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚")
            return [] # è¿”å›ç©ºåˆ—è¡¨ï¼Œç­‰å¾…å°é–è§£é™¤

        # éæ¿¾å‡º USDT æœ¬ä½ã€æ°¸çºŒåˆç´„ä¸”ç‹€æ…‹ç‚º 'TRADING' çš„äº¤æ˜“å°
        syms = [
            s['symbol'] for s in data['symbols']
            if s['quoteAsset'] == 'USDT'
            and s['contractType'] == 'PERPETUAL'
            and s['status'] == 'TRADING' # åªç›£æ§æ´»èºäº¤æ˜“çš„åˆç´„
        ]
        return [s.replace('USDT','/USDT') for s in syms]
    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP éŒ¯èª¤ç™¼ç”Ÿåœ¨ç²å–æœŸè²¨äº¤æ˜“å°: {http_err} - {http_err.response.text}")
        try:
            error_data = http_err.response.json()
            if error_data.get('code') == -1003 and 'banned' in error_data.get('msg', ''):
                is_ip_banned = True
                ban_match = error_data.get('msg', '').split('banned until ')
                if len(ban_match) > 1:
                    ban_until = int(ban_match[1].split('.')[0])
                    logging.error(f"IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œç›´åˆ° {datetime.fromtimestamp(ban_until / 1000).strftime('%Y-%m-%d %H:%M:%S')}ã€‚")
                else:
                    logging.error(f"IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚")
        except json.JSONDecodeError:
            pass # ç„¡æ³•è§£æ JSON
        return []
    except Exception as e:
        logging.error(f"requests å–å¾—æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []

# ========== ä¸»ç¨‹å¼ ==========
def main():
    global is_ip_banned, ban_until

    # ç²å–åˆå§‹äº¤æ˜“å°åˆ—è¡¨
    all_syms = get_binance_futures_symbols_via_requests()
    if not all_syms and not is_ip_banned: # å¦‚æœæ²’æœ‰ç²å–åˆ°äº¤æ˜“å°ä¸”ä¸æ˜¯å› ç‚º IP å°é–
        logging.error("ç„¡æœŸè²¨åˆç´„å¯ç›£æ§ï¼Œç¨‹å¼çµæŸã€‚")
        send_alert("ğŸ”´ ç›£æ§å™¨å•Ÿå‹•å¤±æ•—ï¼šç„¡æœŸè²¨åˆç´„å¯ç›£æ§ã€‚")
        sys.exit(1)
    elif not all_syms and is_ip_banned:
        logging.warning("å•Ÿå‹•æ™‚ IP è¢«å°é–ï¼Œç­‰å¾…å°é–è§£é™¤å¾Œé‡è©¦ç²å–äº¤æ˜“å°åˆ—è¡¨ã€‚")
        # åœ¨é€™è£¡ä¸é€€å‡ºï¼Œè€Œæ˜¯é€²å…¥ä¸»å¾ªç’°ç­‰å¾…å°é–è§£é™¤

    # å»ºç«‹æ­·å²è³‡æ–™çµæ§‹
    # åªæœ‰ç•¶æˆåŠŸç²å–åˆ°äº¤æ˜“å°æ™‚æ‰åˆå§‹åŒ– history
    if all_syms:
        for s in all_syms:
            history[s] = {
                'spot': deque(),
                'futures': deque(),
                'last_alert_time': None
            }
        init_msg = f"ğŸ›°ï¸ Ashdata ç›£æ§å•Ÿå‹•ï¼šå…±åµæ¸¬åˆ° {len(all_syms)} å€‹å¯ç›£æ§åˆç´„ã€‚"
        logging.info(init_msg)
        send_alert(init_msg)
        sample = all_syms[:20]
        notice = (
            f"ğŸ›°ï¸ Ashdata æ½›åœ¨ç›£æ§åå–®ï¼ˆç¤ºä¾‹å‰20ç­†ï¼Œå…±{len(all_syms)}ï¼‰ï¼š\n"
            + "\n".join(sample)
        )
        send_alert(notice)
    else:
        logging.info("æœªç²å–åˆ°åˆå§‹äº¤æ˜“å°åˆ—è¡¨ï¼Œå°‡åœ¨å¾ªç’°ä¸­å˜—è©¦ç²å–ã€‚")

    # ä¸»å¾ªç’°
    while True:
        loop_start_time = time.time()

        if is_ip_banned:
            current_time_ms = int(time.time() * 1000)
            if current_time_ms < ban_until:
                remaining_seconds = (ban_until - current_time_ms) / 1000
                logging.warning(f"IP ä»è¢«å°é–ï¼Œå‰©é¤˜ç´„ {remaining_seconds:.0f} ç§’ã€‚ç­‰å¾…...")
                time.sleep(min(60, remaining_seconds)) # æœ€å¤šç­‰å¾… 60 ç§’ï¼Œæˆ–ç›´åˆ°å°é–è§£é™¤
                continue # ç¹¼çºŒä¸‹ä¸€æ¬¡å¾ªç’°æª¢æŸ¥å°é–ç‹€æ…‹
            else:
                logging.info("IP å°é–å·²è§£é™¤ï¼Œå˜—è©¦é‡æ–°ç²å–äº¤æ˜“å°åˆ—è¡¨ã€‚")
                is_ip_banned = False
                ban_until = 0
                # é‡æ–°ç²å–äº¤æ˜“å°åˆ—è¡¨
                all_syms = get_binance_futures_symbols_via_requests()
                if not all_syms:
                    logging.error("IP è§£é™¤å°é–å¾Œæœªèƒ½é‡æ–°ç²å–äº¤æ˜“å°åˆ—è¡¨ï¼Œå°‡åœ¨ä¸‹ä¸€æ¬¡å¾ªç’°é‡è©¦ã€‚")
                    time.sleep(10) # ç­‰å¾…ä¸€æ®µæ™‚é–“å†é‡è©¦
                    continue
                
                # æ›´æ–° history çµæ§‹
                new_history = {}
                for s in all_syms:
                    if s in history:
                        new_history[s] = history[s] # ä¿ç•™èˆŠçš„æ­·å²æ•¸æ“š
                    else:
                        new_history[s] = {'spot': deque(), 'futures': deque(), 'last_alert_time': None}
                history.clear()
                history.update(new_history)
                
                logging.info(f"é‡æ–°è¼‰å…¥ {len(all_syms)} å€‹å¯ç›£æ§åˆç´„ã€‚")
                send_alert(f"ğŸŸ¢ ç›£æ§å™¨ï¼šIP å°é–å·²è§£é™¤ï¼Œå·²é‡æ–°è¼‰å…¥ {len(all_syms)} å€‹åˆç´„ã€‚")


        # å¦‚æœç›£æ§åˆ—è¡¨ç‚ºç©ºï¼ˆä¾‹å¦‚å•Ÿå‹•æ™‚ IP è¢«å°é–ï¼Œæˆ–éæ¿¾å¾Œç„¡æœ‰æ•ˆäº¤æ˜“å°ï¼‰ï¼Œå‰‡å˜—è©¦å†æ¬¡ç²å–
        if not all_syms:
            logging.info("ç›£æ§åˆ—è¡¨ç‚ºç©ºï¼Œå˜—è©¦é‡æ–°ç²å–äº¤æ˜“å°ã€‚")
            all_syms = get_binance_futures_symbols_via_requests()
            if not all_syms:
                logging.error("æœªèƒ½ç²å–äº¤æ˜“å°åˆ—è¡¨ï¼Œç­‰å¾… 30 ç§’å¾Œé‡è©¦ã€‚")
                time.sleep(30)
                continue
            
            # æ›´æ–° history çµæ§‹ (åŒä¸Š)
            new_history = {}
            for s in all_syms:
                if s in history:
                    new_history[s] = history[s]
                else:
                    new_history[s] = {'spot': deque(), 'futures': deque(), 'last_alert_time': None}
            history.clear()
            history.update(new_history)
            logging.info(f"æˆåŠŸé‡æ–°ç²å– {len(all_syms)} å€‹å¯ç›£æ§åˆç´„ã€‚")
            send_alert(f"ğŸŸ¢ ç›£æ§å™¨ï¼šå·²é‡æ–°ç²å– {len(all_syms)} å€‹åˆç´„ã€‚")


        # éæ­·æ‰€æœ‰äº¤æ˜“å°ç²å–æ•¸æ“š
        requests_this_loop = 0
        for symbol in all_syms:
            if is_ip_banned: # åœ¨æ¯æ¬¡è«‹æ±‚å‰æª¢æŸ¥æ˜¯å¦è¢«å°é–
                logging.warning("IP è¢«å°é–ï¼Œåœæ­¢ç•¶å‰ OI ç²å–å¾ªç’°ã€‚")
                break

            base_asset = symbol.split('/')[0]
            spot_sym = f"{base_asset}/USDT"

            # ç²å–ç¾è²¨åƒ¹æ ¼ (ä½¿ç”¨ CCXT çš„ REST API)
            try:
                # ç²å– 1 åˆ†é˜ OHLCV æ”¶ç›¤åƒ¹
                ohlcv = binance_spot.fetch_ohlcv(spot_sym, '1m', limit=2)
                if ohlcv and len(ohlcv) >= 2:
                    curr_spot_price = ohlcv[-1][4] # æœ€æ–°æ”¶ç›¤åƒ¹
                    now = datetime.utcnow()
                    history[symbol]['spot'].append((now, curr_spot_price))
                    # ä¿ç•™æœ€è¿‘ 15 åˆ†é˜è³‡æ–™
                    cutoff = now - timedelta(minutes=16)
                    history[symbol]['spot'] = deque([(t, v) for t, v in history[symbol]['spot'] if t >= cutoff])
                    logging.debug(f"[ç¾è²¨æ•¸æ“š] {symbol}: {curr_spot_price} (æ™‚é–“: {now.strftime('%H:%M:%S')})")
                    requests_this_loop += 1
                else:
                    logging.warning(f"ç„¡æ³•ç²å– {spot_sym} çš„ç¾è²¨ OHLCV æ•¸æ“šã€‚")
            except ccxt.NetworkError as e:
                logging.error(f"CCXT ç¶²è·¯éŒ¯èª¤ç²å–ç¾è²¨åƒ¹æ ¼ {spot_sym}: {e}")
                # é€™è£¡å¯ä»¥æ ¹æ“šéŒ¯èª¤é¡å‹åˆ¤æ–·æ˜¯å¦ç‚º IP å°é–ï¼Œä½† CCXT å…§éƒ¨æœƒè™•ç†éƒ¨åˆ†é€Ÿç‡é™åˆ¶
            except ccxt.ExchangeError as e:
                logging.warning(f"CCXT äº¤æ˜“æ‰€éŒ¯èª¤ç²å–ç¾è²¨åƒ¹æ ¼ {spot_sym}: {e}")
            except Exception as e:
                logging.error(f"ç²å–ç¾è²¨åƒ¹æ ¼ {spot_sym} ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")

            time.sleep(binance_spot.rateLimit / 1000) # éµå®ˆäº¤æ˜“æ‰€é€Ÿç‡é™åˆ¶

            # ç²å–æœŸè²¨æŒå€‰é‡ (ä½¿ç”¨ CCXT çš„ REST API)
            try:
                oi_data = binance_futures.fetch_open_interest(symbol)
                curr_oi = float(oi_data['openInterest'])
                now = datetime.utcnow()
                history[symbol]['futures'].append((now, curr_oi))
                # ä¿ç•™æœ€è¿‘ 15 åˆ†é˜è³‡æ–™
                cutoff = now - timedelta(minutes=16)
                history[symbol]['futures'] = deque([(t, v) for t, v in history[symbol]['futures'] if t >= cutoff])
                logging.debug(f"[æŒå€‰é‡æ•¸æ“š] {symbol}: {curr_oi} (æ™‚é–“: {now.strftime('%H:%M:%S')})")
                requests_this_loop += 1
            except ccxt.NetworkError as e:
                logging.error(f"CCXT ç¶²è·¯éŒ¯èª¤ç²å–æŒå€‰é‡ {symbol}: {e}")
                # æª¢æŸ¥æ˜¯å¦ç‚º IP å°é–éŒ¯èª¤ç¢¼
                if "Way too many requests" in str(e) or "418" in str(e):
                    is_ip_banned = True
                    # CCXT çš„éŒ¯èª¤è¨Šæ¯å¯èƒ½ä¸åŒ…å« banUntilï¼Œé€™è£¡éœ€è¦æ‰‹å‹•è§£ææˆ–å‡è¨­ä¸€å€‹å°é–æ™‚é–“
                    ban_until = int(time.time() * 1000) + 5 * 60 * 1000 # å‡è¨­å°é– 5 åˆ†é˜
                    logging.error(f"IP è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œå°‡æš«åœæ•¸æ“šç²å–ã€‚é è¨ˆè§£é™¤æ™‚é–“: {datetime.fromtimestamp(ban_until / 1000).strftime('%Y-%m-%d %H:%M:%S')}")
                    send_alert(f"ğŸ”´ ç›£æ§å™¨ï¼šæ‚¨çš„ IP å·²è¢«å¹£å®‰æš«æ™‚å°é–ï¼Œè«‹ç¨å¾Œé‡è©¦ã€‚é è¨ˆè§£é™¤æ™‚é–“: {datetime.fromtimestamp(ban_until / 1000).strftime('%Y-%m-%d %H:%M:%S')}ã€‚")
                elif "-4108" in str(e) and "Symbol is on delivering" in str(e):
                    logging.warning(f"äº¤æ˜“å° {symbol} ç‹€æ…‹ç„¡æ•ˆï¼Œå°‡å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ã€‚éŒ¯èª¤: {e}")
                    all_syms.remove(symbol) # å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ç„¡æ•ˆäº¤æ˜“å°
                    if symbol in history:
                        del history[symbol]
                else:
                    logging.error(f"CCXT äº¤æ˜“æ‰€éŒ¯èª¤ç²å–æŒå€‰é‡ {symbol}: {e}")
            except ccxt.ExchangeError as e:
                logging.warning(f"CCXT äº¤æ˜“æ‰€éŒ¯èª¤ç²å–æŒå€‰é‡ {symbol}: {e}")
                if "-4108" in str(e) and "Symbol is on delivering" in str(e):
                    logging.warning(f"äº¤æ˜“å° {symbol} ç‹€æ…‹ç„¡æ•ˆï¼Œå°‡å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ã€‚éŒ¯èª¤: {e}")
                    all_syms.remove(symbol) # å¾ç›£æ§åˆ—è¡¨ä¸­ç§»é™¤ç„¡æ•ˆäº¤æ˜“å°
                    if symbol in history:
                        del history[symbol]
            except Exception as e:
                logging.error(f"ç²å–æŒå€‰é‡ {symbol} ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")
            
            time.sleep(binance_futures.rateLimit / 1000) # éµå®ˆäº¤æ˜“æ‰€é€Ÿç‡é™åˆ¶

            if is_ip_banned: # å¦‚æœè¢«å°é–ï¼Œç«‹å³è·³å‡ºç•¶å‰å¾ªç’°
                break

        # æª¢æŸ¥ä¸¦ç™¼é€è­¦å ±
        for symbol in all_syms:
            if symbol in history: # ç¢ºä¿è©²ç¬¦è™Ÿçš„æ­·å²æ•¸æ“šå­˜åœ¨
                format_and_send(symbol, history[symbol]['spot'], history[symbol]['futures'])

        # æ§åˆ¶ä¸»å¾ªç’°çš„é »ç‡ï¼Œç¢ºä¿ä¸æœƒéåº¦è«‹æ±‚
        # ç¸½å»¶é² = æ¯å€‹è«‹æ±‚çš„å»¶é² * è«‹æ±‚æ•¸é‡ + é¡å¤–ç·©è¡æ™‚é–“
        # å‡è¨­æ¯å€‹äº¤æ˜“å°éœ€è¦ 2 å€‹è«‹æ±‚ (ç¾è²¨ + æœŸè²¨)
        # å¹£å®‰çš„å…¬å…± API é™åˆ¶é€šå¸¸æ˜¯ 1200 è«‹æ±‚/åˆ†é˜
        # æˆ‘å€‘å¸Œæœ›åœ¨ 1 åˆ†é˜å…§å®Œæˆæ‰€æœ‰äº¤æ˜“å°çš„è«‹æ±‚ï¼Œä¸¦ç•™æœ‰é¤˜è£•
        # å¦‚æœæœ‰ 100 å€‹äº¤æ˜“å°ï¼Œ100 * 2 = 200 è«‹æ±‚
        # 1 åˆ†é˜æœ‰ 60 ç§’ï¼Œæ‰€ä»¥å¹³å‡æ¯ç§’å¯ä»¥ç™¼é€ 200/60 = 3.33 è«‹æ±‚
        # CCXT çš„ rateLimit å·²ç¶“æœƒæ§åˆ¶å–®å€‹äº¤æ˜“æ‰€çš„è«‹æ±‚é–“éš”
        # é€™è£¡æˆ‘å€‘æ§åˆ¶æ•´å€‹å¾ªç’°çš„æœ€å°é–“éš”
        
        # ç¢ºä¿æ•´å€‹å¾ªç’°è‡³å°‘é‹è¡Œ 60 ç§’ï¼Œé¿å…éåº¦é »ç¹çš„ API å‘¼å«
        elapsed_time = time.time() - loop_start_time
        min_loop_interval = 60 # è‡³å°‘ 60 ç§’åŸ·è¡Œä¸€æ¬¡å®Œæ•´å¾ªç’°
        
        if elapsed_time < min_loop_interval:
            sleep_duration = min_loop_interval - elapsed_time
            logging.info(f"æœ¬è¼ªå¾ªç’°è€—æ™‚ {elapsed_time:.2f} ç§’ï¼Œç­‰å¾… {sleep_duration:.2f} ç§’é€²å…¥ä¸‹ä¸€è¼ªã€‚")
            time.sleep(sleep_duration)
        else:
            logging.info(f"æœ¬è¼ªå¾ªç’°è€—æ™‚ {elapsed_time:.2f} ç§’ï¼Œç›´æ¥é€²å…¥ä¸‹ä¸€è¼ªã€‚")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logging.info("ç¨‹å¼è¢«ä½¿ç”¨è€…ä¸­æ–·ã€‚")
    except Exception as e:
        logging.error(f"ç¨‹å¼ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {e}", exc_info=True)

