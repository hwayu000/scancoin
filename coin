import os
import sys
import time
import logging
import requests
# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from datetime import datetime, timedelta
from dotenv import load_dotenv
load_dotenv()
try:
    import ccxt
except ImportError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt

# ========== è¨­å®š logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== åƒæ•¸è¨­å®š ==========

# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4617157719')
# ç¢ºèª Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN æˆ– TELEGRAM_CHAT_ID æœªè¨­å®šï¼è«‹æª¢æŸ¥ .env æª”")
    sys.exit(1)

# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ ==========
exchanges = {
    'binance': ccxt.binance({'enableRateLimit': True}),
    'bybit': ccxt.bybit({'enableRateLimit': True}),
    'okx': ccxt.okx({'enableRateLimit': True}),
    'bitget': ccxt.bitget({'enableRateLimit': True}),
    'mexc': ccxt.mexc({'enableRateLimit': True}),
    'gate': ccxt.gate({'enableRateLimit': True}),
}

binance_futures = ccxt.binance({
    'options': {'defaultType': 'future'},
    'enableRateLimit': True
})
#####################################
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # è½‰æˆ ccxt æ ¼å¼ï¼ˆBTCUSDT -> BTC/USDTï¼‰
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        print(f"requests å–å¾— Binance æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []

symbols = get_binance_futures_symbols_via_requests()

############################
# ========== ç›´æ¥ç”¨ requests å–å¾— Binance æœŸè²¨ USDT äº¤æ˜“å°æ¸…å–® ==========
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # è½‰æˆ ccxt æ ¼å¼ï¼ˆBTCUSDT -> BTC/USDTï¼‰
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        logging.error(f"requests å–å¾— Binance æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []

# ========== ç™¼é€è­¦å ± ==========
# ========== ç™¼é€è­¦å ± ==========
def send_alert(message):
    tg_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    tg_payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
    try:
        tg_resp = requests.post(tg_url, data=tg_payload, timeout=10)
        if tg_resp.status_code != 200:
            logging.warning(f"Telegram ç™¼é€å¤±æ•—: {tg_resp.text}")
    except Exception as e:
        logging.error(f"Telegram ç™¼é€ç•°å¸¸: {e}")

# ========== é–¾å€¼è¨­å®š ==========
PRICE_TIERS = [(5.0,'â­â­â­â­'),(4.0,'â­â­â­'),(3.0,'â­â­'),(2.0,'â­')]
OI_TIERS    = [(5.0,'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥'),(3.5,'ğŸ”¥ğŸ”¥ğŸ”¥'),(3.0,'ğŸ”¥ğŸ”¥'),(2.5,'ğŸ”¥')]

# ========== æ ¼å¼åŒ–ä¸¦ç™¼é€ ==========
def format_and_send(symbol, spot_hist, fut_hist):
    # spot_hist/fut_hist ç‚º list of tuples (ts, value)
    def pct(arr, mins):
        # æ‰¾è·ä»Šå¤§ç´„ mins ç­†å‰çš„æ•¸å€¼
        for ts,val in reversed(arr):
            if ts <= datetime.utcnow() - timedelta(minutes=mins): 
                old = val; break
        else:
            return 0.0
        new = arr[-1][1]
        return (new-old)/old*100 if old else 0.0

    p1 = pct(spot_hist, 1);  p5 = pct(spot_hist, 5);  p15 = pct(spot_hist,15)
    o1 = pct(fut_hist, 1);   o5 = pct(fut_hist, 5);   o15 = pct(fut_hist,15)

    price_alert = max(abs(p1),abs(p5),abs(p15))>=PRICE_TIERS[-1][0]
    oi_alert    = max(abs(o1),abs(o5),abs(o15))>=OI_TIERS[-1][0]
    if not price_alert and not oi_alert:
        return

    lines = [f"ğŸ›°ï¸â€¯Ashdataæ¨™çš„ç›£æ§\näº¤æ˜“å°ï¼š{symbol}"]
    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

    if price_alert:
        stars = next(r for th,r in PRICE_TIERS if abs(p1)>=th or abs(p5)>=th or abs(p15)>=th)
        lines += [
            f"ğŸ“ˆâ€¯åƒ¹æ ¼ç•°å‹• {stars}",
            f" â€¢ 1m: {p1:+.2f}% 5m: {p5:+.2f}% 15m: {p15:+.2f}%"
        ]

    if oi_alert:
        fires = next(r for th,r in OI_TIERS if abs(o1)>=th or abs(o5)>=th or abs(o15)>=th)
        cor = (p1*o1>0 and p5*o5>0 and p15*o15>0)
        note = "" if cor else " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"
        lines += [
            f"ğŸ’¹â€¯æŒå€‰ç•°å‹• {fires}{note}",
            f" â€¢ 1m: {o1:+.2f}% 5m: {o5:+.2f}% 15m: {o15:+.2f}%"
        ]

    lines.append(f"æ™‚é–“ï¼š{now}")
    send_alert("\n".join(lines))

# ========== æ­·å²è³‡æ–™å„²å­˜ ==========
history = {}  # {symbol: {'spot': [(timestamp, price, volume)], 'futures': [(timestamp, open_interest)]}}

# ========== ä¸»å¾ªç’° ==========
# ========== ä¸»å¾ªç’° ==========
history = {}  # symbolâ†’{'spot':[(ts,val)],'futures':[(ts,val)]}

def main():
    syms = get_binance_futures_symbols_via_requests()
    if not syms:
        logging.error("ç„¡åˆç´„å¯ç›£æ§ï¼Œç¨‹å¼çµæŸ"); return

    # å•Ÿå‹•é€šçŸ¥
    init_msg = f"ğŸ›°ï¸ Ashdataç›£æ§å•Ÿå‹•ï¼šå…±åµæ¸¬åˆ° {len(syms)} å€‹åˆç´„"
    logging.info(init_msg); send_alert(init_msg)

    # init history
    for s in syms:
        history[s] = {'spot':[], 'futures':[]}

    while True:
        t0 = time.time()
        for symbol in syms:
            base = symbol.split('/')[0]
            spot_sym = f"{base}/USDT"

            # pick best spot ex
            best_ex, maxv = None,0
            for ex in exchanges.values():
                if spot_sym not in ex.symbols: continue
                try:
                    qv=ex.fetch_ticker(spot_sym).get('quoteVolume',0)
                    if qv>maxv: best_ex,maxv=ex,qv
                except: pass
            if not best_ex: continue

            # fetch spot 1m price
            try:
                ohlcv=best_ex.fetch_ohlcv(spot_sym,'1m',limit=2)
                prev=ohlcv[-2][4]; curr=ohlcv[-1][4]
            except: continue

            # fetch futures OI
            try:
                curr_oi=float(binance_futures.fetch_open_interest(symbol)['openInterest'])
            except: continue

            now=datetime.utcnow()
            sh=history[symbol]['spot']; fh=history[symbol]['futures']
            sh.append((now,curr)); fh.append((now,curr_oi))

            # clean >15min
            cutoff=now-timedelta(minutes=15)
            history[symbol]['spot']   =[x for x in sh if x[0]>=cutoff]
            history[symbol]['futures']=[x for x in fh if x[0]>=cutoff]

            # format & alert
            format_and_send(symbol, history[symbol]['spot'], history[symbol]['futures'])
            time.sleep(0.2)

        elapsed=time.time()-t0
        if elapsed<60: time.sleep(60-elapsed)

if __name__=='__main__':
    main()
