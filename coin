import os
import sys
import time
import logging
import requests
# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from datetime import datetime, timedelta
from dotenv import load_dotenv
load_dotenv()
try:
    import ccxt
except ImportError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt

# ========== è¨­å®š logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== åƒæ•¸è¨­å®š ==========

# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')
# ç¢ºèª Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN æˆ– TELEGRAM_CHAT_ID æœªè¨­å®šï¼è«‹æª¢æŸ¥ .env æª”")
    sys.exit(1)

# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ ==========
# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ä¸¦é è¼‰å¸‚å ´ ==========
exchanges = {
    name: getattr(ccxt, name)({'enableRateLimit': True})
    for name in ['binance','bybit','okx','bitget','mexc','gateio']
}
binance_futures = ccxt.binance({
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})
#####################################
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # è½‰æˆ ccxt æ ¼å¼ï¼ˆBTCUSDT -> BTC/USDTï¼‰
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        print(f"requests å–å¾— Binance æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []

symbols = get_binance_futures_symbols_via_requests()

############################
# è¼‰å…¥æ‰€æœ‰ marketsï¼Œä¿è­‰ .markets å¯ç”¨
binance_futures.load_markets()
for ex in exchanges.values():
    try:
        ex.load_markets()
    except Exception as e:
        logging.warning(f"{ex.id} load_markets å¤±æ•—: {e}")
# ========== å–å¾— Binance æœŸè²¨ USDT åˆç´„åˆ—è¡¨ ==========
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        syms = [
            s['symbol'] for s in data['symbols']
            if s['quoteAsset']=='USDT'
            and s['contractType'] in ('PERPETUAL','CURRENT_QUARTER','NEXT_QUARTER')
        ]
        return [s.replace('USDT','/USDT') for s in syms]
    except Exception as e:
        logging.error(f"requests å–å¾—æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []
# ========== ç™¼é€è­¦å ± ==========
# ========== ç™¼é€ Telegram è­¦å ± ==========
def send_alert(message: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
    try:
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            logging.warning(f"Telegram ç™¼é€å¤±æ•—: {r.text}")
    except Exception as e:
        logging.error(f"Telegram ç™¼é€ç•°å¸¸: {e}")
# ========== é–¾å€¼è¨­å®š ==========
PRICE_TIERS = [(5.0,'â­â­â­â­'),(4.0,'â­â­â­'),(3.0,'â­â­'),(2.0,'â­')]
OI_TIERS    = [(5.0,'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥'),(3.5,'ğŸ”¥ğŸ”¥ğŸ”¥'),(3.0,'ğŸ”¥ğŸ”¥'),(2.5,'ğŸ”¥')]

# ========== æ ¼å¼åŒ–ä¸¦ç™¼é€å ±æ–‡ ==========
def format_and_send(symbol, spot_hist, fut_hist):
    def pct(arr, mins):
        cutoff = datetime.utcnow() - timedelta(minutes=mins)
        old = next((v for (t,v) in arr if t <= cutoff), None)
        new = arr[-1][1] if arr else None
        return ((new-old)/old*100) if (old and new is not None) else 0.0

    p1,p5,p15 = pct(spot_hist,1), pct(spot_hist,5), pct(spot_hist,15)
    o1,o5,o15 = pct(fut_hist,1), pct(fut_hist,5), pct(fut_hist,15)

    price_alert = max(abs(p1),abs(p5),abs(p15)) >= PRICE_TIERS[-1][0]
    oi_alert    = max(abs(o1),abs(o5),abs(o15)) >= OI_TIERS[-1][0]
    if not price_alert and not oi_alert:
        return

    now = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
    lines = [f"ğŸ›°ï¸â€¯Ashdataæ¨™çš„ç›£æ§\näº¤æ˜“å°ï¼š{symbol}"]

    if price_alert:
        stars = next(r for th,r in PRICE_TIERS if abs(p1)>=th or abs(p5)>=th or abs(p15)>=th)
        lines += [
            f"ğŸ“ˆâ€¯åƒ¹æ ¼ç•°å‹• {stars}",
            f" â€¢ 1m: {p1:+.2f}% 5m: {p5:+.2f}% 15m: {p15:+.2f}%"
        ]
    if oi_alert:
        fires = next(r for th,r in OI_TIERS if abs(o1)>=th or abs(o5)>=th or abs(o15)>=th)
        cor = (p1*o1>0 and p5*o5>0 and p15*o15>0)
        note = "" if cor else " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"
        lines += [
            f"ğŸ’¹â€¯æŒå€‰ç•°å‹• {fires}{note}",
            f" â€¢ 1m: {o1:+.2f}% 5m: {o5:+.2f}% 15m: {o15:+.2f}%"
        ]

    lines.append(f"æ™‚é–“ï¼š{now}")
    send_alert("\n".join(lines))


# ========== æ­·å²è³‡æ–™å„²å­˜ ==========
history = {}  # {symbol: {'spot': [(timestamp, price, volume)], 'futures': [(timestamp, open_interest)]}}

# ========== ä¸»å¾ªç’° ==========
# ========== ä¸»ç¨‹å¼ ==========
def main():
    syms = get_binance_futures_symbols_via_requests()
    if not syms:
        logging.error("ç„¡æœŸè²¨åˆç´„å¯ç›£æ§ï¼Œç¨‹å¼çµæŸ")
        return

    # å•Ÿå‹•æ™‚åƒ…ç™¼é€ä¸€æ¬¡
    init_msg = f"ğŸ›°ï¸â€¯Ashdataç›£æ§å•Ÿå‹•ï¼šå…±åµæ¸¬åˆ° {len(syms)} å€‹åˆç´„"
    logging.info(init_msg)
    send_alert(init_msg)

    # å»ºç«‹æ­·å²çµæ§‹
    history = {s:{'spot':deque(), 'futures':deque()} for s in syms}

    while True:
        loop_start = time.time()
        for symbol in syms:
            base = symbol.split('/')[0]
            spot_sym = f"{base}/USDT"

            # é¸æˆäº¤é‡æœ€å¤§äº¤æ˜“æ‰€
            best_ex, maxv = None, 0.0
            for ex in exchanges.values():
                if spot_sym not in ex.markets:
                    continue
                try:
                    qv = ex.fetch_ticker(spot_sym).get('quoteVolume',0) or 0
                    if qv > maxv:
                        best_ex, maxv = ex, qv
                except:
                    continue
            if not best_ex:
                continue

            # æŠ“ 1m æ”¶ç›¤åƒ¹
            try:
                ohlcv = best_ex.fetch_ohlcv(spot_sym,'1m',limit=2)
                prev, curr = ohlcv[-2][4], ohlcv[-1][4]
            except:
                continue

            # æŠ“æœŸè²¨ OI
            try:
                curr_oi = float(binance_futures.fetch_open_interest(symbol)['openInterest'])
            except:
                continue

            now = datetime.utcnow()
            sh, fh = history[symbol]['spot'], history[symbol]['futures']
            sh.append((now, curr)); fh.append((now, curr_oi))

            # ä¿ç•™æœ€è¿‘ 15 åˆ†é˜
            cutoff = now - timedelta(minutes=15)
            history[symbol]['spot']   = [(t,v) for t,v in sh if t>=cutoff]
            history[symbol]['futures'] = [(t,v) for t,v in fh if t>=cutoff]

            # æ ¼å¼åŒ–ä¸¦é€šçŸ¥
            format_and_send(symbol, history[symbol]['spot'], history[symbol]['futures'])

            time.sleep(0.2)

        # 1 åˆ†é˜é–“éš”
        elapsed = time.time() - loop_start
        if elapsed < 60:
            time.sleep(60 - elapsed)

if __name__ == "__main__":
    main()
