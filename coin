import os
import time
import requests
import json
import math
from datetime import datetime, timedelta
import pytz # 用於處理時區，這是個好習慣
import re # 用於正規表達式，處理IP封鎖訊息
import asyncio # 用於非同步操作，例如發送Telegram訊息

# --- 配置區塊 ---
# 從環境變數中獲取 Telegram 機器人 Token 和 Chat ID。
# 如果環境變數未設置，則使用預設值。請務必替換為你自己的值！
# 這裡的預設值應該與你在 /etc/environment 中設置的完全一致
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')

# 幣安 API 端點 (不用改動)
BINANCE_FUTURES_EXCHANGE_INFO_URL = "https://fapi.binance.com/fapi/v1/exchangeInfo"
BINANCE_FUTURES_OPEN_INTEREST_URL = "https://fapi.binance.com/fapi/v1/openInterest"
BINANCE_SPOT_MINITICKER_URL = "https://api.binance.com/api/v3/ticker/24hr" # 使用24小時行情API獲取現貨價格

# 價格變動評級閾值
PRICE_TIERS = [
    {"threshold": 5.0, "rating": "⭐⭐⭐⭐"},
    {"threshold": 4.0, "rating": "⭐⭐⭐"},
    {"threshold": 3.0, "rating": "⭐⭐"},
    {"threshold": 2.0, "rating": "⭐"}
]

# 持倉量變動評級閾值
OI_TIERS = [
    {"threshold": 5.0, "rating": "🔥🔥🔥🔥"},
    {"threshold": 3.5, "rating": "🔥🔥🔥"},
    {"threshold": 3.0, "rating": "🔥🔥"},
    {"threshold": 2.5, "rating": "🔥"}
]

# 警報冷卻時間 (分鐘)，避免頻繁發送相同警報
ALERT_COOLDOWN_MINUTES = 5

# 數據儲存：每個交易對的歷史價格、持倉量、警報時間戳等
# 格式: {symbol: {'spot': [{'timestamp': datetime物件, 'value': float}], 'futures': [...], 'last_alert_time': datetime物件, 'first_alert_time': datetime物件, 'subsequent_alert_times': [datetime物件]}}
history_data = {}
monitored_symbols = [] # 目前正在監控的交易對列表，例如：'BTC/USDT'

# IP 封鎖狀態追蹤 (用於幣安 API)
is_ip_banned = False
ban_until = None # datetime 物件，表示封鎖解除的時間

# --- 輔助函數 ---

def calculate_percentage_change(data_array, minutes):
    """
    計算給定數據陣列在指定分鐘內的百分比變動。
    data_array: 包含 {timestamp, value} 字典的列表
    minutes: 時間範圍（分鐘）
    返回值: 百分比變動，如果數據不足則返回 None
    """
    if not data_array:
        return None

    now = datetime.now(pytz.utc) # 獲取當前 UTC 時間
    cutoff_time = now - timedelta(minutes=minutes)

    old_val = None
    # 從數據陣列的末尾開始遍歷，找到最接近或早於截止時間的數據點
    for item in reversed(data_array):
        if item['timestamp'] <= cutoff_time:
            old_val = item['value']
            break

    new_val = data_array[-1]['value'] if data_array else None

    # 如果沒有足夠的數據，或者舊值為 0 (避免除以零)，則返回 None
    if old_val is None or new_val is None or old_val == 0:
        return None

    return ((new_val - old_val) / old_val) * 100

def get_rating_info(value, tiers):
    """
    根據值和定義的評級層級獲取評級符號。
    """
    abs_value = abs(value)
    for tier in tiers:
        if abs_value >= tier["threshold"]:
            return tier["rating"]
    return ""

def format_large_number(num):
    """
    將大數字格式化為帶有 K/M/B 單位和兩位小數的字串。
    """
    if num is None or math.isnan(num):
        return 'N/A'
    if num >= 1_000_000_000:
        return f"{(num / 1_000_000_000):.2f}B"
    elif num >= 1_000_000:
        return f"{(num / 1_000_000):.2f}M"
    elif num >= 1_000:
        return f"{(num / 1_000):.2f}K"
    else:
        return f"{num:.2f}"

async def send_telegram_alert(message):
    """
    透過 Telegram Bot 發送訊息。
    """
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("錯誤：Telegram BOT_TOKEN 或 CHAT_ID 未配置。無法發送訊息。")
        return

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': message,
        'parse_mode': 'HTML' # 使用 HTML 模式，以便發送粗體、換行等格式
    }
    try:
        response = requests.post(url, json=payload, timeout=10) # 設置10秒超時
        response.raise_for_status() # 如果響應狀態碼是 4xx 或 5xx，則拋出 HTTPError 異常
        print(f"DEBUG: Telegram 訊息發送成功: {message.splitlines()[0]}") # 簡化日誌輸出，加入DEBUG
    except requests.exceptions.HTTPError as e:
        print(f"ERROR: 發送 Telegram 訊息失敗: HTTP 錯誤 {e.response.status_code} - {e.response.text}")
    except requests.exceptions.RequestException as e:
        print(f"ERROR: 發送 Telegram 訊息失敗: 網路錯誤 - {e}")
    except Exception as e: # 捕捉其他任何可能的錯誤
        print(f"ERROR: 發送 Telegram 訊息時發生未知錯誤: {e}")


def retry_fetch(url, retries=3, delay=1):
    """
    帶有重試邏輯的 fetch 請求，並處理幣安的 IP 封鎖。
    """
    global is_ip_banned, ban_until # 聲明為全域變數以便修改
    for i in range(retries):
        try:
            response = requests.get(url, timeout=10) # 10秒超時
            response.raise_for_status() # 檢查 HTTP 狀態碼
            is_ip_banned = False # 如果成功，清除封鎖狀態
            ban_until = None
            return response.json()
        except requests.exceptions.HTTPError as e:
            error_text = e.response.text
            print(f"WARNING: 第 {i + 1} 次獲取失敗: {url}，狀態碼 {e.response.status_code}: {error_text}")

            # 檢查是否為 IP 封鎖錯誤 (HTTP 418, 429 或幣安特定的錯誤碼 -1003)
            if e.response.status_code in [418, 429] or ("-1003" in error_text and "banned" in error_text):
                is_ip_banned = True
                ban_match = re.search(r"banned until (\d+)", error_text) # 嘗試解析封鎖解除時間戳
                if ban_match:
                    ban_timestamp_ms = int(ban_match.group(1))
                    ban_until = datetime.fromtimestamp(ban_timestamp_ms / 1000, tz=pytz.utc) # 轉換為 datetime 物件
                    print(f"CRITICAL: IP 已被幣安封鎖，直到: {ban_until.strftime('%Y-%m-%d %H:%M:%S %Z')}")
                else:
                    ban_until = datetime.now(pytz.utc) + timedelta(minutes=5) # 如果沒有具體時間，假設封鎖 5 分鐘
                    print("CRITICAL: IP 已被幣安封鎖 (未提供具體時間)，假定封鎖 5 分鐘。")

                raise Exception(f"IP 被封鎖: {error_text}") # 拋出異常，讓上層邏輯處理等待
            else:
                if i < retries - 1:
                    wait_time = delay * (2 ** i) # 指數退避，等待時間加倍
                    print(f"INFO: 將在 {wait_time} 秒後重試...")
                    time.sleep(wait_time)
                else:
                    raise e # 最後一次嘗試失敗，拋出原始錯誤
        except requests.exceptions.RequestException as e:
            print(f"ERROR: 第 {i + 1} 次獲取網路錯誤: {url}: {e}")
            if i < retries - 1:
                wait_time = delay * (2 ** i)
                print(f"INFO: 將在 {wait_time} 秒後重試...")
                time.sleep(wait_time)
            else:
                raise e # 最後一次嘗試失敗，拋出原始錯誤

    raise Exception(f"CRITICAL: 在 {retries} 次重試後，仍無法獲取 {url}。")

# --- 數據獲取和處理 ---

def initialize_monitoring_symbols():
    """
    動態獲取並設定要監控的交易對列表。
    """
    global monitored_symbols, history_data, is_ip_banned, ban_until # 聲明為全域變數

    print("INFO: 正在獲取可監控的期貨交易對列表...")
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
        print(f"WARNING: IP 仍然被封鎖，剩餘 {remaining_time:.0f} 秒。跳過交易對初始化。")
        return False # 返回 False 表示初始化失敗

    is_ip_banned = False # 在嘗試獲取之前重置 IP 封鎖狀態

    try:
        response_data = retry_fetch(BINANCE_FUTURES_EXCHANGE_INFO_URL)
        # 過濾出 USDT 本位、永續合約且狀態為 'TRADING' 的交易對
        valid_symbols = [
            s['symbol'].replace('USDT', '/USDT')
            for s in response_data['symbols']
            if s['quoteAsset'] == 'USDT' and s['contractType'] == 'PERPETUAL' and s['status'] == 'TRADING'
        ]

        monitored_symbols = valid_symbols

        # 重新初始化 history_data，保留已存在的數據，為新加入的交易對建立空歷史數據
        new_history_data = {}
        for symbol in monitored_symbols:
            if symbol in history_data:
                new_history_data[symbol] = history_data[symbol] # 保留舊數據
            else:
                new_history_data[symbol] = {
                    'spot': [],
                    'futures': [],
                    'last_alert_time': None,
                    'first_alert_time': None,
                    'subsequent_alert_times': []
                }
        history_data = new_history_data # 更新全域變數

        print(f"INFO: 已載入 {len(monitored_symbols)} 個期貨交易對: {monitored_symbols[:5]}...") # 只顯示前5個以節省日誌空間
        if not monitored_symbols:
            print("WARNING: 沒有找到可監控的交易對。")
            return False
        return True # 返回 True 表示初始化成功

    except Exception as e:
        print(f"ERROR: 獲取期貨交易對列表失敗: {e}")
        return False

def fetch_spot_prices():
    """
    獲取所有監控交易對的當前現貨價格。
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    # print("INFO: 正在獲取現貨價格...") # 避免過多日誌
    try:
        # 獲取所有 24 小時行情數據，然後進行篩選
        all_tickers = retry_fetch(BINANCE_SPOT_MINITICKER_URL)
        now = datetime.now(pytz.utc)

        for ticker in all_tickers:
            symbol_raw = ticker['symbol']
            formatted_symbol = symbol_raw.replace('USDT', '/USDT')
            price = float(ticker['lastPrice'])

            if formatted_symbol in monitored_symbols:
                # 確保 history_data 中有該交易對的條目
                if formatted_symbol not in history_data:
                    history_data[formatted_symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
                history_data[formatted_symbol]['spot'].append({'timestamp': now, 'value': price})

                # 清理舊數據，只保留最近 16 分鐘的數據（多保留一點確保計算準確）
                cutoff = now - timedelta(minutes=16)
                while len(history_data[formatted_symbol]['spot']) > 0 and history_data[formatted_symbol]['spot'][0]['timestamp'] < cutoff:
                    history_data[formatted_symbol]['spot'].pop(0)

    except Exception as e:
        print(f"ERROR: 獲取現貨價格失敗: {e}")


def fetch_open_interest_rest():
    """
    獲取每個監控交易對的期貨持倉量數據。
    """
    global history_data
    if is_ip_banned and ban_until and datetime.now(pytz.utc) < ban_until:
        return

    # print("INFO: 正在獲取期貨持倉量...") # 避免過多日誌
    delay_between_requests = 0.5 # 每個請求之間間隔 0.5 秒

    # 遍歷監控的交易對列表的副本，因為列表中可能會有元素被移除
    for symbol in list(monitored_symbols):
        binance_symbol = symbol.replace('/', '') # 轉換成幣安 API 需要的格式 (例如 BTCUSDT)
        url = f"{BINANCE_FUTURES_OPEN_INTEREST_URL}?symbol={binance_symbol}"
        try:
            data = retry_fetch(url)
            open_interest = float(data['openInterest'])
            now = datetime.now(pytz.utc)

            # 確保 history_data 中有該交易對的條目
            if symbol not in history_data:
                history_data[symbol] = {'spot': [], 'futures': [], 'last_alert_time': None, 'first_alert_time': None, 'subsequent_alert_times': []}
            history_data[symbol]['futures'].append({'timestamp': now, 'value': open_interest})

            # 清理舊數據，只保留最近 16 分鐘的數據
            cutoff = now - timedelta(minutes=16)
            while len(history_data[symbol]['futures']) > 0 and history_data[symbol]['futures'][0]['timestamp'] < cutoff:
                history_data[symbol]['futures'].pop(0)

        except Exception as e:
            print(f"ERROR: 獲取 {symbol} 持倉量失敗: {e}")
            if "IP BANNED" in str(e):
                return # 如果 IP 被封鎖，停止當前循環
            if "-4108" in str(e) and "Symbol is on delivering" in str(e):
                print(f"WARNING: 交易對 {symbol} 狀態無效 ('Symbol is on delivering')，將從監控列表中移除。")
                monitored_symbols.remove(symbol) # 從監控列表中移除該交易對
                if symbol in history_data:
                    del history_data[symbol] # 也從歷史數據中移除
        finally:
            # 在每個請求之間添加一個小延遲，避免觸發速率限制
            time.sleep(delay_between_requests)

def check_and_send_alerts():
    """
    檢查是否有顯著的價格/持倉量變動，並發送 Telegram 警報。
    """
    global history_data
    now = datetime.now(pytz.utc)

    # 遍歷監控的交易對列表的副本，因為列表中可能會有元素被移除
    for symbol in list(monitored_symbols):
        if symbol not in history_data:
            continue

        spot_hist = history_data[symbol]['spot']
        fut_hist = history_data[symbol]['futures']

        # 計算百分比變動
        p1 = calculate_percentage_change(spot_hist, 1)
        p5 = calculate_percentage_change(spot_hist, 5)
        p15 = calculate_percentage_change(spot_hist, 15)

        o1 = calculate_percentage_change(fut_hist, 1)
        o5 = calculate_percentage_change(fut_hist, 5)
        o15 = calculate_percentage_change(fut_hist, 15)

        # 獲取評級資訊 (如果為 None 則傳入 0，以確保 max 函數正常工作)
        price_rating = get_rating_info(max(abs(p1) if p1 is not None else 0, abs(p5) if p5 is not None else 0, abs(p15) if p15 is not None else 0), PRICE_TIERS)
        oi_rating = get_rating_info(max(abs(o1) if o1 is not None else 0, abs(o5) if o5 is not None else 0, abs(o15) if o15 is not None else 0), OI_TIERS)

        # 判斷是否達到警報閾值 (使用最低閾值作為觸發條件)
        price_alert_threshold_met = (
            (p1 is not None and abs(p1) >= PRICE_TIERS[-1]["threshold"]) or
            (p5 is not None and abs(p5) >= PRICE_TIERS[-1]["threshold"]) or
            (p15 is not None and abs(p15) >= PRICE_TIERS[-1]["threshold"])
        )

        oi_alert_threshold_met = (
            (o1 is not None and abs(o1) >= OI_TIERS[-1]["threshold"]) or
            (o5 is not None and abs(o5) >= OI_TIERS[-1]["threshold"]) or
            (o15 is not None and abs(o15) >= OI_TIERS[-1]["threshold"])
        )

        # 檢查冷卻時間，避免頻繁警報
        last_alert_time = history_data[symbol]['last_alert_time']
        if last_alert_time and (now - last_alert_time).total_seconds() / 60 < ALERT_COOLDOWN_MINUTES:
            # print(f"INFO: 符號 {symbol} 仍在冷卻中，跳過警報。") # 避免過多日誌
            continue # 仍在冷卻期，跳過此交易對的警報

        alert_message_parts = []
        is_alert_triggered = False

        # 處理價格警報
        if price_alert_threshold_met:
            price_alert_message = (
                f"📈 <b>價格異動 {price_rating}評級 - #{symbol}:</b>\n" # 在幣種前加 #
                f"• 1m: {p1:.2f}% | 5m: {p5:.2f}% | 15m: {p15:.2f}%"
            )
            alert_message_parts.append(price_alert_message)
            is_alert_triggered = True

        # 處理持倉量警報
        if oi_alert_threshold_met:
            # 判斷是否有反向關聯，即價格下跌而持倉量增加 (疑是空方進場)
            note = ""
            # 判斷標準：如果價格變化為負（下跌），且持倉量變化為正（增加），則提示「疑是空方進場」
            # 我們會檢查1m, 5m, 15m中至少一個符合此條件
            has_bearish_oi_increase = False
            if p1 is not None and o1 is not None and p1 < 0 and o1 > 0:
                has_bearish_oi_increase = True
            if p5 is not None and o5 is not None and p5 < 0 and o5 > 0:
                has_bearish_oi_increase = True
            if p15 is not None and o15 is not None and p15 < 0 and o15 > 0:
                has_bearish_oi_increase = True

            if has_bearish_oi_increase:
                note = " ⚠️疑是空方進場"

            oi_alert_message = (
                f"💹 <b>持倉異動 {oi_rating}{note} - #{symbol}:</b>\n" # 在幣種前加 #
                f"• 1m: {o1:.2f}% | 5m: {o5:.2f}% | 15m: {o15:.2f}%"
            )
            alert_message_parts.append(oi_alert_message)
            is_alert_triggered = True

        # 如果有警報被觸發，則發送合併後的警報訊息
        if is_alert_triggered:
            # 更新警報時間戳
            if history_data[symbol]['first_alert_time'] is None:
                history_data[symbol]['first_alert_time'] = now
                history_data[symbol]['subsequent_alert_times'] = []
            else:
                history_data[symbol]['subsequent_alert_times'].append(now)

            # 組合訊息的最後一行，包含首次觸發和上次觸發時間
            timestamp_info = ""
            first_alert_str = history_data[symbol]['first_alert_time'].strftime("%Y-%m-%d %H:%M:%S")
            timestamp_info += f"\n首次觸發時間: {first_alert_str} (UTC)"

            if history_data[symbol]['subsequent_alert_times']:
                # 取得最近一次的後續觸發時間
                last_subsequent_str = history_data[symbol]['subsequent_alert_times'][-1].strftime("%Y-%m-%d %H:%M:%S")
                timestamp_info += f"\n上次觸發時間: {last_subsequent_str} (UTC)"

            final_alert_message = "\n\n".join(alert_message_parts) + timestamp_info

            # 發送 Telegram 警報
            asyncio.run(send_telegram_alert(final_alert_message))
            history_data[symbol]['last_alert_time'] = now # 更新冷卻計時器

# --- 主應用程式循環 ---

async def main_loop():
    """
    主要循環，負責獲取數據和檢查警報。
    """
    global is_ip_banned, ban_until

    # --- 程式啟動確認訊息 ---
    start_message = "Ashdata掃鏈程式已啟動！正在初始化交易對列表..."
    print(f"DEBUG: 嘗試發送啟動訊息: {start_message}") # 新增日誌
    try:
        await send_telegram_alert(start_message)
        print("DEBUG: 啟動訊息發送成功。") # 新增日誌
    except Exception as e:
        print(f"ERROR: 啟動訊息發送失敗: {e}") # 新增錯誤日誌

    # 首次嘗試初始化交易對。如果失敗，則等待並重試。
    init_success = False
    while not init_success:
        init_success = initialize_monitoring_symbols()
        if not init_success:
            print("WARNING: 初始化交易對失敗。將在 60 秒後重試...")
            try: # 嘗試發送錯誤訊息到 Telegram
                await send_telegram_alert("⚠️ 錯誤：Ashdata掃鏈初始化失敗，正在重試。請檢查伺服器日誌。")
            except:
                pass # 避免再次失敗導致循環
            await asyncio.sleep(60)

    # 初始化成功後，再次發送訊息，包含偵測到的標的數量
    startup_complete_message = f"Ashdata掃鏈已偵測到 <b>{len(monitored_symbols)}</b> 種標的。監控服務正式啟動！"
    print(f"DEBUG: 嘗試發送啟動完成訊息: {startup_complete_message}") # 新增日誌
    try:
        await send_telegram_alert(startup_complete_message)
        print("DEBUG: 啟動完成訊息發送成功。") # 新增日誌
    except Exception as e:
        print(f"ERROR: 啟動完成訊息發送失敗: {e}") # 新增錯誤日誌

    while True:
        if is_ip_banned:
            if ban_until and datetime.now(pytz.utc) < ban_until:
                # 如果還在封鎖期內，計算剩餘時間並等待
                remaining_time = (ban_until - datetime.now(pytz.utc)).total_seconds()
                print(f"WARNING: IP 仍然被封鎖。將等待 {remaining_time:.0f} 秒後重試所有數據獲取。")
                try: # 嘗試發送 IP 封鎖訊息到 Telegram
                    await send_telegram_alert(f"⚠️ 警報：Ashdata掃鏈IP已被幣安暫時封鎖，剩餘約 {remaining_time:.0f} 秒。")
                except:
                    pass
                await asyncio.sleep(max(10, remaining_time + 5)) # 使用 asyncio.sleep
                continue # 跳過本次數據獲取循環
            else:
                # 如果 IP 封鎖可能已解除，嘗試清除封鎖狀態並重新初始化
                print("INFO: IP 封鎖可能已解除。正在嘗試清除封鎖狀態並重新初始化。")
                is_ip_banned = False
                ban_until = None
                # 重新初始化交易對，確保獲取到最新的列表並重置連接
                init_success = initialize_monitoring_symbols()
                if not init_success:
                    print("WARNING: 解除封鎖後的重新初始化失敗。將在 60 秒後重試...")
                    try: # 嘗試發送錯誤訊息到 Telegram
                        await send_telegram_alert("⚠️ 錯誤：Ashdata掃鏈解除IP封鎖後初始化失敗，正在重試。")
                    except:
                        pass
                    await asyncio.sleep(60)
                    continue

        # 獲取現貨價格和持倉量
        print("INFO: 開始獲取現貨價格和期貨持倉量...")
        fetch_spot_prices()
        fetch_open_interest_rest() # 這個函數內部會處理每個交易對之間的延遲
        print("INFO: 完成數據獲取。")

        # 檢查並發送警報
        print("INFO: 檢查並發送警報...")
        check_and_send_alerts()
        print("INFO: 警報檢查完成。")

        # 根據監控的交易對數量計算下一次獲取數據的間隔時間
        min_fetch_interval = 60 # 秒
        calculated_fetch_interval = len(monitored_symbols) * 0.5 + 10 # 估計獲取時間 + 緩衝
        next_interval = max(min_fetch_interval, calculated_fetch_interval)

        print(f"INFO: 下一次數據獲取和警報檢查將在 {next_interval:.0f} 秒後進行...") # 避免過多日誌
        await asyncio.sleep(next_interval) # 使用 asyncio.sleep 進行非同步等待

if __name__ == "__main__":
    asyncio.run(main_loop())
