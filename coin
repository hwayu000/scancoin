import os
import sys
import time
import logging
import requests

# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from datetime import datetime, timedelta
from dotenv import load_dotenv
from collections import deque 
load_dotenv()
try:
    import ccxt
except ImportError:
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "ccxt"])
    import ccxt
# ========== è¨­å®š logging ==========
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s',
    handlers=[logging.StreamHandler()]
)

# ========== åƒæ•¸è¨­å®š ==========

# ========== è¼‰å…¥ç’°å¢ƒè®Šæ•¸ ==========
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '6005276002:AAGN9u1k7xEmfwpe6nkJqhOPjsEwGttJGzM')
TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '-4946614597')
# ç¢ºèª Token & Chat ID
if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
    logging.error("TELEGRAM_BOT_TOKEN æˆ– TELEGRAM_CHAT_ID æœªè¨­å®šï¼è«‹æª¢æŸ¥ .env æª”")
    sys.exit(1)

# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ ==========
# ========== åˆå§‹åŒ–äº¤æ˜“æ‰€ä¸¦é è¼‰å¸‚å ´ ==========
exchanges = {
    name: getattr(ccxt, name)({'enableRateLimit': True})
    for name in ['binance','bybit','okx','bitget','mexc','gateio']
}
binance_futures = ccxt.binance({
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})
#####################################
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        symbols = [
            s['symbol'] for s in data['symbols']
            if s['contractType'] in ['PERPETUAL', 'CURRENT_QUARTER', 'NEXT_QUARTER']
            and s['quoteAsset'] == 'USDT'
        ]
        # è½‰æˆ ccxt æ ¼å¼ï¼ˆBTCUSDT -> BTC/USDTï¼‰
        symbols = [s.replace('USDT', '/USDT') for s in symbols]
        return symbols
    except Exception as e:
        print(f"requests å–å¾— Binance æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []

symbols = get_binance_futures_symbols_via_requests()

############################
# è¼‰å…¥æ‰€æœ‰ marketsï¼Œä¿è­‰ .markets å¯ç”¨
binance_futures.load_markets()
for ex in exchanges.values():
    try:
        ex.load_markets()
    except Exception as e:
        logging.warning(f"{ex.id} load_markets å¤±æ•—: {e}")
# ========== å–å¾— Binance æœŸè²¨ USDT åˆç´„åˆ—è¡¨ ==========
def get_binance_futures_symbols_via_requests():
    url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
    try:
        data = requests.get(url, timeout=10).json()
        syms = [
            s['symbol'] for s in data['symbols']
            if s['quoteAsset']=='USDT'
            and s['contractType'] in ('PERPETUAL','CURRENT_QUARTER','NEXT_QUARTER')
        ]
        return [s.replace('USDT','/USDT') for s in syms]
    except Exception as e:
        logging.error(f"requests å–å¾—æœŸè²¨äº¤æ˜“å°å¤±æ•—: {e}")
        return []
# ========== ç™¼é€è­¦å ± ==========
# ========== ç™¼é€ Telegram è­¦å ± ==========
def send_alert(message: str):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message}
    try:
        r = requests.post(url, data=payload, timeout=10)
        if r.status_code != 200:
            logging.warning(f"Telegram ç™¼é€å¤±æ•—: {r.text}")
    except Exception as e:
        logging.error(f"Telegram ç™¼é€ç•°å¸¸: {e}")
# ========== é–¾å€¼è¨­å®š ==========
PRICE_TIERS = [(5.0,'â­â­â­â­'),(4.0,'â­â­â­'),(3.0,'â­â­'),(2.0,'â­')]
OI_TIERS    = [(5.0,'ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥'),(3.5,'ğŸ”¥ğŸ”¥ğŸ”¥'),(3.0,'ğŸ”¥ğŸ”¥'),(2.5,'ğŸ”¥')]

# ========== æ ¼å¼åŒ–ä¸¦ç™¼é€å ±æ–‡ ==========
# ========== æ ¼å¼åŒ–ä¸¦ç™¼é€å ±æ–‡ ==========
def format_and_send(symbol, spot_hist, fut_hist, best_ex_id, timeframe):
    # è¨ˆç®—ç™¾åˆ†æ¯”è®Šå‹•
    def pct(arr, mins):
        cutoff = datetime.utcnow() - timedelta(minutes=mins)
        old = next((v for (t, v) in arr if t <= cutoff), None)
        new = arr[-1][1] if arr else None
        return ((new - old) / old * 100) if (old and new is not None) else 0.0

    p1, p5, p15 = pct(spot_hist, 1), pct(spot_hist, 5), pct(spot_hist, 15)
    o1, o5, o15 = pct(fut_hist, 1), pct(fut_hist, 5), pct(fut_hist, 15)

    price_alert = max(abs(p1), abs(p5), abs(p15)) >= PRICE_TIERS[-1][0]
    oi_alert    = max(abs(o1), abs(o5), abs(o15)) >= OI_TIERS[-1][0]
    if not price_alert and not oi_alert:
        return

    # 1ï¸âƒ£ ç¬¬ä¸€æ®µï¼šæ¨™é¡Œ
    if price_alert:
        stars = next(r for th, r in PRICE_TIERS if abs(p1) >= th or abs(p5) >= th or abs(p15) >= th)
        header = f"ğŸ“ˆâ€¯åƒ¹æ ¼ç•°å‹• {stars}è©•ç´š"
    else:
        fires = next(r for th, r in OI_TIERS if abs(o1) >= th or abs(o5) >= th or abs(o15) >= th)
        cor   = (p1 * o1 > 0 and p5 * o5 > 0 and p15 * o15 > 0)
        note  = "" if cor else " âš ï¸ç–‘æ˜¯ç©ºæ–¹é€²å ´"
        header = f"ğŸ’¹â€¯æŒå€‰ç•°å‹• {fires}{note}"

    # 2ï¸âƒ£ ç¬¬äºŒæ®µï¼šäº¤æ˜“æ‰€ + äº¤æ˜“å°
    pair_line = f"{best_ex_id}:{symbol.replace('/', '')}"

    # 3ï¸âƒ£ ç¬¬ä¸‰æ®µï¼šTimeframe
    tf_line = f"Timeframe: {timeframe}"

    # ç´°ç¯€è¡Œ
    lines = [header, pair_line, tf_line]
    if price_alert:
        lines.append(f" â€¢ 1m: {p1:+.2f}% 5m: {p5:+.2f}% 15m: {p15:+.2f}%")
    if oi_alert:
        lines.append(f" â€¢ 1m: {o1:+.2f}% 5m: {o5:+.2f}% 15m: {o15:+.2f}%")

    lines.append(f"æ™‚é–“ï¼š{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}")
    send_alert("\n".join(lines))

# ========== æ­·å²è³‡æ–™å„²å­˜ ==========
history = {}  # {symbol: {'spot': [(timestamp, price, volume)], 'futures': [(timestamp, open_interest)]}}

# ========== ä¸»å¾ªç’° ==========
# ========== ä¸»ç¨‹å¼ ==========
def main():
    all_syms = get_binance_futures_symbols_via_requests()
    if not all_syms:
        logging.error("ç„¡æœŸè²¨åˆç´„å¯ç›£æ§ï¼Œç¨‹å¼çµæŸ")
        return

    # éæ¿¾å‡ºè‡³å°‘ä¸€å€‹ç¾è²¨äº¤æ˜“æ‰€æ”¯æ´çš„åˆç´„
    potential_syms = []
    for sym in all_syms:
        spot_sym = f"{sym.split('/')[0]}/USDT"
        if any(spot_sym in ex.markets for ex in exchanges.values()):
            potential_syms.append(sym)
        else:
            logging.info(f"{sym} ç„¡ç¾è²¨å¸‚å ´æ”¯æ´ï¼Œè·³é")

    if not potential_syms:
        logging.error("ç¶“ééæ¿¾å¾Œï¼Œæ²’æœ‰ä»»ä½•å¯ç›£æ§çš„åˆç´„")
        return

    # å…ˆç™¼æ½›åœ¨åå–®å‰ 20 ç­†åˆ° Telegram
    sample = potential_syms[:20]
    notice = (
        f"ğŸ›°ï¸â€¯Ashdata æ½›åœ¨ç›£æ§åå–®ï¼ˆç¤ºä¾‹å‰20ç­†ï¼Œå…±{len(potential_syms)}ï¼‰ï¼š\n"
        + "\n".join(sample)
    )
    logging.info(notice)
    send_alert(notice)

    # å•Ÿå‹•é€šçŸ¥
    init_msg = f"ğŸ›°ï¸â€¯Ashdataç›£æ§å•Ÿå‹•ï¼šå…±åµæ¸¬åˆ° {len(potential_syms)} å€‹å¯ç›£æ§åˆç´„"
    logging.info(init_msg)
    send_alert(init_msg)

    # å»ºç«‹æ­·å²è³‡æ–™çµæ§‹
    history = {s: {'spot': deque(), 'futures': deque()} for s in potential_syms}

    while True:
        start = time.time()
        for symbol in potential_syms:
            base     = symbol.split('/')[0]
            spot_sym = f"{base}/USDT"

            # é¸æˆäº¤é‡æœ€å¤§ç¾è²¨äº¤æ˜“æ‰€
            best_ex, maxv = None, 0.0
            for ex in exchanges.values():
                if spot_sym not in ex.markets:
                    continue
                try:
                    vol = ex.fetch_ticker(spot_sym).get('quoteVolume', 0) or 0
                    if vol > maxv:
                        best_ex, maxv = ex, vol
                except:
                    continue
            if not best_ex:
                continue

            # æŠ“ 1 åˆ†é˜ OHLCV æ”¶ç›¤åƒ¹
            try:
                ohlcv = best_ex.fetch_ohlcv(spot_sym, '1m', limit=2)
                prev, curr = ohlcv[-2][4], ohlcv[-1][4]
            except:
                continue

            # æŠ“æœŸè²¨æŒå€‰é‡
            try:
                curr_oi = float(binance_futures.fetch_open_interest(symbol)['openInterest'])
            except:
                continue

            now = datetime.utcnow()
            sh, fh = history[symbol]['spot'], history[symbol]['futures']
            sh.append((now, curr))
            fh.append((now, curr_oi))

            # ä¿ç•™æœ€è¿‘ 15 åˆ†é˜è³‡æ–™
            cutoff = now - timedelta(minutes=15)
            history[symbol]['spot']   = [(t, v) for t, v in sh if t >= cutoff]
            history[symbol]['futures'] = [(t, v) for t, v in fh if t >= cutoff]

            # æ ¼å¼åŒ–ä¸¦ç™¼é€è­¦å ±
            format_and_send(symbol, history[symbol]['spot'],
                            history[symbol]['futures'],
                            best_ex.id, '1m')

            time.sleep(0.2)

        elapsed = time.time() - start
        if elapsed < 60:
            time.sleep(60 - elapsed)

if __name__ == "__main__":
    main()
